# The fast Fourier transform

```{python}
import numpy as np
import math
import matplotlib.pyplot as plt
import random
import timeit
import scipy.fftpack
from mpl_toolkits.mplot3d import Axes3D
```

## How the FFT works, speed tests

The loop-based implementation of the discrete time Fourier transform, only is
useful as simple example to demistify its inner mechanisms, but is too slow
for practical applications. The actual fast Fourier transform (FFT) first
places all of the complex sine waves as the columns of a matrix, in a matrix
(one column per wave), and the signal in a column vector, and then apply matrix multiplication (instead of applying the dot product in a loop). The next step
is to decompose this matrix into a lot of separate matrices that are very
sparse (non-zero elements), which can be easily processed by modern computers.
A more detailed description would require to delve deeper into concepts from
linear algebra, such as matrix decomposition. The point here is that is
advisable to use the highly efficient implementations of that are readily
available.

### Python

We create the a fully random signal with `np.random.randn`and apply the slow
loop-based Fourier transform. The only novelty is the tic-toc variables, that
store when `timeit.default_timer()` has been called. By substracting the
timestamps we see how long the function has taken.

```{python}
# create the signal
pnts   = 1000
signal = np.random.randn(pnts)


# start the timer for "slow" Fourier transform
tic = timeit.default_timer()

# prepare the Fourier transform
fourTime = np.array(range(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(pnts):
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )


# end timer for slow Fourier transform
toc = timeit.default_timer()
t1 = toc-tic

# time the fast Fourier transform
tic = timeit.default_timer()
fCoefsF = scipy.fftpack.fft(signal)
toc = timeit.default_timer()
t2 = toc-tic

# and plot
plt.bar([1,2],[t1,t2])
plt.title('Computation times')
plt.ylabel('Time (sec.)')
plt.xticks([1,2], ['loop','FFT'])
plt.show()

```

The loop-based transform is much slower!. This difference grows with the length
of the signal, so it is wise to use the fater version.

With this code, I want to show you that the FFT still needs the same two normalization factors that

I discussed in a previous video.

So here I am generating a signal.

It's a sine wave with six hertz and an amplitude of two.

Now, if I run this code, you'll see again that the amplitude is wrong.

This is not the correct amplitude.

The frequency is correct.

So that part's good, but the amplitude is not correct.

And just like with the previous video where I talked about these normalizations, you can increase this

from two to four seconds.

Now, this was of amplitude value of 2000.

Now it's up to 4000.

So, again, you need to apply the same two normalization factors here.

So the first one, if you remember, was to divide the Fourier coefficients by the number of points

in the signal, which in this case is variable npnts.

So I can do that.

Now we get an amplitude of one, which is half of the real amplitude of the simulated signal.

And so, therefore, we need to apply the second normalization factor, which is to add the negative

frequency coefficients onto the positive frequency coefficients, which in practice we just do by multiplying

the amplitude of the positive coefficients by two.

So this now accurately reconstructs the parameters of the simulation.

And of course, you also remember that this is a shortcut.

This is not entirely accurate.

This is not totally true.

This is now improperly scaling by two the DC component.

And in this specific case, it doesn't really matter because the DC component is zero.

So as long as you're aware that this is a bit of a shortcut and it will be accurate for the positive

frequencies, but inaccurate for the zero frequency, then I think it's it's OK to leave it like this.

In this video, I showed you how to use the FFT function in Matlab to implement the Fourier transform.

As I mentioned before, the loop-based discrete Fourier transform that you've been working with so far

in this course has a very large educational value.

It's really the best way to learn about how the Fourier transform works and how to interpret the outputs

of the Fourier transform.

But in practice, you should always use the FFT function and never use that loop based discrete Fourier

transform function.


```python
## fft still need normalizations

srate = 1000
time  = np.arange(0,2,1/srate)
npnts = len(time)

# signal
signal = 2*np.sin(2*np.pi*6*time)

# Fourier spectrum
signalX = scipy.fftpack.fft(signal)
hz = np.linspace(0,srate,npnts)

# amplitude
ampl = np.abs(signalX[0:len(hz)])

plt.stem(hz,ampl)
plt.xlim(0,10)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude (a.u.)')
plt.show()
```


---
# VIDEO: The fast inverse Fourier transform
---



```python
# set parameters
srate = 1000
time  = np.arange(0,3,1/srate)
pnts  = len(time)

# create multispectral signal
signal  = np.multiply( (1+np.sin(2*np.pi*12*time)) , np.cos(np.sin(2*np.pi*25*time)+time) )

# fft
signalX = scipy.fftpack.fft(signal)

# reconstruction via ifft
reconSig = scipy.fftpack.ifft(signalX)

plt.plot(time,signal,label='Original')
plt.plot(time,np.real(reconSig),label='Reconstructed')
plt.xlabel('Time (sec.)')
plt.ylabel('amplitude (a.u.)')
plt.show()
```


---
# VIDEO: The perfection of the Fourier transform
---



```python
# number of time points
pnts = 1000 

# prepare the Fourier transform
fourTime = np.array(range(0,pnts))/pnts
F        = np.zeros((pnts,pnts),dtype=complex)

for fi in range(0,pnts):
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # put csw into column of matrix F
    F[:,fi] = csw

# compute inverse of F (and normalize by N)
Finv = np.linalg.inv(F)*pnts

# plot one sine wave
plt.plot(fourTime,np.real(F[:,5]),label='real')
plt.plot(fourTime,np.imag(F[:,5]),label='imag')
plt.title('One column of matrix F')
plt.legend()
plt.show()

plt.plot(fourTime,np.real(Finv[:,5]),label='real')
plt.plot(fourTime,np.imag(Finv[:,5]),label='imag')
plt.title('One column of matrix F$^{-1}$')
plt.legend()
plt.show()
```

# VIDEO: Using the fft on matrices


```python
# using the matlib library
import numpy.matlib

# generate multivariate dataset

srate = 400
time  = np.arange(0,srate*2)/srate
npnts = len(time)
nreps = 50

# dataset is repeated sine waves
data = np.matlib.repmat( np.sin(2*np.pi*10*time), nreps,1 )
```


```python
# FFT of data along each dimension

dataX1 = scipy.fftpack.fft(data,axis=0) / npnts
dataX2 = scipy.fftpack.fft(data,axis=1) / npnts
hz = np.linspace(0,srate/2,int(np.floor(npnts/2)+1))

# check sizes
print(np.shape(dataX1))
print(np.shape(dataX2))
```


```python
# show data and spectra!
plt.imshow(data)
plt.xlabel('Time')
plt.ylabel('Channel')
plt.title('Time-domain signal')
plt.show()

plt.stem(hz,np.mean( 2*abs(dataX1[:,:len(hz)]),axis=0),'k')
plt.xlabel('Frequency (??)')
plt.ylabel('Amplitude')
plt.title('FFT over channels')
plt.show()

plt.stem(hz,np.mean( 2*abs(dataX2[:,:len(hz)]),axis=0),'k')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('FFT over time')
plt.show()
```
