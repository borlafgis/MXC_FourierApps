# Code for Section 4: The discrete inverse Fourier transform

```{python}
import numpy as np
import math
from matplotlib import colormaps
from matplotlib.collections import LineCollection
import matplotlib.pyplot as plt
import pylab as pl
from IPython import display
import time as ttime
import random
from mpl_toolkits.mplot3d import Axes3D
```


## Inverse discrete Fourier transform

The forward Fourier transform converts signals from time- to frequency domain
using complex sine waves. The algorithm works by generating waves with different
frequencies and asessing which amplitude and phase that provide the best match
with the original signal (Fourier coefficients).

The inverse fourier transform is the opposite process. It takes the Fourier
coefficients describing the waves characteristics of each frquency sine waves.
Thus, it is just a matter of repeating the following steps for each frequency:

1. Create a complex sine wave with the same number of time points as the signal
   and a frequency defined by point-1 (???).

2. Multiply that sine wave by the complex Fourier coefficient (from the forward
   Fourier transform).

3. Sum the modulated (and multiplied) complex sine waves together.

Divide the result by $N$ (because the loop involved summing over $N$), obtaining
the original signal.

You can think of these complex sine waves like templates, which need to be
be modulated by the amplitude and phase given by the complex Fourier
coefficients.

### Python

#### Forward transform

First we create a signal by summing two sine waves, with frequencies of $4$ and
$6.5$ Hz whose amplitudes are $2.5$ and $1.5$. The we apply the forward Fourier
transform.

```{python}
## first, the forward Fourier transform

# create the signal
srate  = 1000 # hz
time   = np.arange(0,2.,1/srate)  # time vector in seconds
pnts   = len(time) # number of time points
signal = 2.5 * np.sin( 2*np.pi*4*time ) + 1.5 * np.sin( 2*np.pi*6.5*time )


# prepare the Fourier transform
fourTime = np.array(np.arange(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(0,pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )

# extract amplitudes
ampls = np.abs(fCoefs) / pnts
ampls[range(1,len(ampls))] = 2*ampls[range(1,len(ampls))]

# compute frequencies vector
hz = np.linspace(0,srate/2,num=math.floor(pnts/2)+1)

plt.stem(hz,ampls[range(0,len(hz))])
plt.xlim([0,10])
plt.show()
```

#### Inverse transform (1st way)

Now we reconstruct the signal using the inverse Fourier transform. We
initialize the vector for the reconstructed signal (`reconSignal`), and loop
over the Fourier coefficients of the frequencies.
(or the time points, they have the same count).
For each of them we multiply the `fi` Fourier coefficient by a template sine
wave with frequency `fi` 
(modulation of the complex sine wave by the complex Fourier coefficient).
Then, each sine wave is added to the the reconstructed signal. Once the looping
has finished, the reconstructed signal is divided by its lenth to
[WHY??]. If we plot the original and the reconstructed signal we can see they
match quite well. 

```{python}
## the inverse Fourier transform

# initialize time-domain reconstruction
reconSignal = np.zeros(len(signal));

for fi in range(0,pnts):
    
    # create coefficient-modulated complex sine wave
    csw = fCoefs[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    
    # sum them together
    reconSignal = reconSignal + csw


# divide by N
reconSignal = reconSignal/pnts

plt.plot(time, signal, label='original')
plt.plot(time, np.real(reconSignal), 'r.', label='reconstructed')
plt.legend()
plt.show() 

# note: signals are entire overlapping. you can try zooming in
```

Note that the formula used to create the template sine waves has a slight
difference with respect with the formula used on the forward transform. In this
case the minus sign is absent to ensue imaginary coefficients are canceled in
the inverse transform.
[this absence imposes a phase shift into the inverse Fourier transform??].
This is related to the cosine identity: both a positive and negative complex
exponentials need to be summed to obtain 
a real-valued cosine wave, and, in this case, to reconstruct a real-valued
signal.

Also note that even though the results should be real-valued, we apply
`np.real` to take care of near-zero imaginary component for waves near the
Nyquist frequency that are caused by computer rounding errors.

### Inverse (2nd way)

To highlight the concept of the inverse Fourier transform we create a rather
bizarre multispectral signal (e.g., a sine embedded in the cosine), apply the
forward Fourier transform, and then reconstruct the signal frequency by
frequency using its inverse inverse.

The frequency and time domain are represented on the upper and lower part of
the plot. Each line on the time domain has been reconstructed with all the
frequencies equal or under the value depicted on its label. We casn see that
the more frequancues we add, the cloaser we ger to the original signal. When
we reach [N] we have perfectly reconstructed the original signal.

Note that if we just sum up the positive frequencies (up to [N]), the result
is very similar to the full sum, albeit it is missing half of the amplitude
that is contained by the negative frequencies.

### Areas of application

Many signal processing algorithms (convolution, filtering, cross correlation),
can be applied in a more efficient way whilst on the frequency domain. Thus,
it is necessary to use the forward transform to benefit from these speed up,
and then return the signal to the time domain using the inverse transform.



```{python}
## partial reconstruction of signal
# this differs from the MATLAB code because in-loop graphics updating 
# in python is version- and platform-dependent. Instead, here you can
# specify the proportion of frequencies to use when reconstructing the
# original time-domain signal.


# proportion of frequencies (from 0-srate) to reconstruct (.5 is Nyquist)
propfrex = .5

# set parameters
srate = 1000
time  = np.arange(0, 3, 1/srate)
pnts  = len(time)

# create multispectral signal
signal  = np.multiply(
    (1 + np.sin(2 * np.pi * 12 * time)),  
    np.cos(np.sin(2 * np.pi * 25 * time) + time)
    )

# prepare the Fourier transform
fourTime = np.arange(0, pnts)/pnts
fCoefs   = np.zeros(len(signal), dtype=complex)

# here is the Fourier transform...
for fi in range(0,pnts):
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    fCoefs[fi] = np.sum( np.multiply(signal,csw) ) / pnts

fig, axs = plt.subplots(2, 1)

# Plot the signal on the frequency domain using a gradient
hz = np.linspace(0, srate, num=pnts)
amplitude = 2 * np.abs(fCoefs)

# Create the line collection from the coordinates
points = np.expand_dims(np.stack([hz, amplitude], axis=1), axis=1)
segments = np.hstack([points[:-1], points[1:]])
lc = LineCollection(segments)
lc.set_array(hz)

# add the collection to the ax and st up the ax limits
axs[0].add_collection(lc);
axs[0].set_title("Frequency domain")
axs[0].set_ylim(0, amplitude.max())
axs[0].set_xlim(0, hz.max())
axs[0].set_xticks(np.arange(0, int(srate/2) + 1, 100))
axs[0].set_xlabel("Frequency (Hz)")

# initialize the reconstructed signal
reconSignal = np.zeros(pnts, dtype=complex)

# inverse Fourier transform here
for fi in range(pnts):#int(propfrex*pnts)):
    
    # create coefficient-modulated complex sine wave
    csw = fCoefs[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    
    # sum them together
    reconSignal += csw

    if fi in [10, 1500, 2999]:

        axs[1].plot(
            time,
            np.real(reconSignal),
            zorder=-fi,
            color=plt.cm.viridis(fi/(pnts-1)),
            label=r"n$^{\circ}$" + str(fi))
        #print(colors[fi])

axs[1].legend(title="Reconstructed with frequencies up to...", ncols=3)
axs[1].set_title("Time domain")
axs[1].set_xlim(time[0], time[-1])
axs[1].set_xlabel("Time (s)")

fig.tight_layout()
```

# Inverse Fourier transform for signal processing


As previously stated, the application of many signal processing algorithms is
more efficient on the time domain. For example, in the case of band-stop
filtering we take transform the signal, change the amplitudes or the phase
values in the frequency domain, and then compute the inverse Fourier transform
to get back to the time domain. Note this procedure is useful only when there
are clearly spectral separable components in the signal.

## Python

First we create a signal with a pair of two sine waves at 4 and 10 hertz and
compute the Fourierr Transform.

```{python}
srate = 1000
time  = np.arange(0,2-1/srate,1/srate)
pnts  = len(time)

# signal 
signal = np.sin(2*np.pi*4*time) + np.sin(2*np.pi*10*time)


# Fourier transform
fourTime = np.array(np.arange(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(0,pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )/pnts


# frequencies in Hz
hz = np.linspace(0,srate/2,int(np.floor(pnts/2.0)+1))

# now plot
plt.plot(time,signal)
plt.title('Original signal, time domain')
plt.show()
```

On the amplitude spectrum we see these two frequencies are perfectly
reconstructed on the frequency domain.

```{python}
# plot original amplitude spectrum
plt.stem(hz,2*np.abs(fCoefs[0:len(hz)]))
plt.xlim([0,25])
plt.title('Original signal, frequency domain')
plt.show()
```

Then we eliminate the 10 Hz frequency component, recovering just a pure sine
wave at 4 hertz. To do this we identify the frequency index corresponding to
10 hertz and we set that Fourier coefficient to 0. However, if we just do that,
we see the result is is similar to the original with some dampening (less
amplitude). This is because the amplitude the 10 hertz component is split
between the positive and the negative frequencies. If we only zero out the
positive frequency but not the negative, we are just halving the amplitude of
that frequency. if we also remove the corresponding negative frequency using a
negative index. Remember these do not have the DC component, so it is necessary
to add an additional offset. After doing the removal we reconstruct the signal,
and we can see there is only a 4 Hertz component.

```{python}
# find the coefficient for 10 Hz
freqidx = np.argmin(np.abs(hz-10))

# set the positive coefficient to zero
fCoefsPositive = fCoefs.copy()
fCoefsPositive[freqidx] = 0

# set both negative and positive coefficients to 0 
fCoefsBoth = fCoefs.copy()
fCoefsBoth[freqidx] = 0
fCoefsBoth[-freqidx] = 0 

# and compute inverse
reconPositive = np.zeros(len(signal),dtype=complex)
reconBoth = np.zeros(len(signal),dtype=complex)

for fi in range(0,pnts):
    reconPositive += fCoefsPositive[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    reconBoth += fCoefsBoth[fi] * np.exp( 1j*2*np.pi*fi*fourTime )

# and plot modulated time series
plt.plot(time,signal)
plt.plot(time, np.real(reconPositive))
plt.plot(time, np.real(reconBoth))
plt.title('Band-stop filtered signal, time domain')
plt.show()
```

In this example, we can see why this procedure is appropriate only for signals
that have clearly spectrally separable components: if two components of the
signal overlapped in the frequency domain, just removing some of them would not
isolate one part of the signal.

Another caveat is that zeroing Fourier coefficients can introduce artifacts in
the time domain signal. In this case, this very hard edge filter happens to
work really well because the signal contains only pure sine waves, but in
general it is preferrable to have a gentle slope instead of a hard edge. This
is explained on the section about the effects of non-stationarity, as well as
on the course on signal processing (section on filter design).