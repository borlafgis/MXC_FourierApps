# Code for Section 4: The discrete inverse Fourier transform

```{python}
import numpy as np
import math
from matplotlib import colormaps
from matplotlib.collections import LineCollection
import matplotlib.pyplot as plt
import pylab as pl
from IPython import display
import time as ttime
import random
from mpl_toolkits.mplot3d import Axes3D
```


## Inverse discrete Fourier transform

The forward Fourier transform converts signals from time- to frequency domain
using complex sine waves. The algorithm works by generating waves with different
frequencies and asessing which amplitude and phase that provide the best match
with the original signal (Fourier coefficients).

The inverse fourier transform is the opposite process. It takes the Fourier
coefficients describing the waves characteristics of each frquency sine waves.
Thus, it is just a matter of repeating the following steps for each frequency:

1. Create a complex sine wave with the same number of time points as the signal
   and a frequency defined by point-1 (???).

2. Multiply that sine wave by the complex Fourier coefficient (from the forward
   Fourier transform).

3. Sum the modulated (and multiplied) complex sine waves together.

Divide the result by $N$ (because the loop involved summing over $N$), obtaining
the original signal.

You can think of these complex sine waves like templates, which need to be
be modulated by the amplitude and phase given by the complex Fourier
coefficients.

### Python

#### Forward transform

First we create a signal by summing two sine waves, with frequencies of $4$ and
$6.5$ Hz whose amplitudes are $2.5$ and $1.5$. The we apply the forward Fourier
transform.

```{python}
## first, the forward Fourier transform

# create the signal
srate  = 1000 # hz
time   = np.arange(0,2.,1/srate)  # time vector in seconds
pnts   = len(time) # number of time points
signal = 2.5 * np.sin( 2*np.pi*4*time ) + 1.5 * np.sin( 2*np.pi*6.5*time )


# prepare the Fourier transform
fourTime = np.array(np.arange(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(0,pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )

# extract amplitudes
ampls = np.abs(fCoefs) / pnts
ampls[range(1,len(ampls))] = 2*ampls[range(1,len(ampls))]

# compute frequencies vector
hz = np.linspace(0,srate/2,num=math.floor(pnts/2)+1)

plt.stem(hz,ampls[range(0,len(hz))])
plt.xlim([0,10])
plt.show()
```

#### Inverse transform (1st way)

Now we reconstruct the signal using the inverse Fourier transform. We
initialize the vector for the reconstructed signal (`reconSignal`), and loop
over the Fourier coefficients of the frequencies.
(or the time points, they have the same count).
For each of them we multiply the `fi` Fourier coefficient by a template sine
wave with frequency `fi` 
(modulation of the complex sine wave by the complex Fourier coefficient).
Then, each sine wave is added to the the reconstructed signal. Once the looping
has finished, the reconstructed signal is divided by its lenth to
[WHY??]. If we plot the original and the reconstructed signal we can see they
match quite well. 

```{python}
## the inverse Fourier transform

# initialize time-domain reconstruction
reconSignal = np.zeros(len(signal));

for fi in range(0,pnts):
    
    # create coefficient-modulated complex sine wave
    csw = fCoefs[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    
    # sum them together
    reconSignal = reconSignal + csw


# divide by N
reconSignal = reconSignal/pnts

plt.plot(time, signal, label='original')
plt.plot(time, np.real(reconSignal), 'r.', label='reconstructed')
plt.legend()
plt.show() 

# note: signals are entire overlapping. you can try zooming in
```

Note that the formula used to create the template sine waves has a slight
difference with respect with the formula used on the forward transform. In this
case the minus sign is absent to ensue imaginary coefficients are canceled in
the inverse transform.
[this absence imposes a phase shift into the inverse Fourier transform??].
This is related to the cosine identity: both a positive and negative complex
exponentials need to be summed to obtain 
a real-valued cosine wave, and, in this case, to reconstruct a real-valued
signal.

Also note that even though the results should be real-valued, we apply
`np.real` to take care of near-zero imaginary component for waves near the
Nyquist frequency that are caused by computer rounding errors.

### Inverse (2nd way)

To highlight the concept of the inverse Fourier transform we create a rather
bizarre multispectral signal (e.g., a sine embedded in the cosine), apply the
forward Fourier transform, and then reconstruct the signal frequency by
frequency using its inverse inverse.

The frequency and time domain are represented on the upper and lower part of
the plot. Each line on the time domain has been reconstructed with all the
frequencies equal or under the value depicted on its label. We casn see that
the more frequancues we add, the cloaser we ger to the original signal. When
we reach [N] we have perfectly reconstructed the original signal.

Note that if we just sum up the positive frequencies (up to [N]), the result
is very similar to the full sum, albeit it is missing half of the amplitude
that is contained by the negative frequencies.

### Areas of application

Many signal processing algorithms (convolution, filtering, cross correlation),
can be applied in a more efficient way whilst on the frequency domain. Thus,
it is necessary to use the forward transform to benefit from these speed up,
and then return the signal to the time domain using the inverse transform.



```{python}
## partial reconstruction of signal
# this differs from the MATLAB code because in-loop graphics updating 
# in python is version- and platform-dependent. Instead, here you can
# specify the proportion of frequencies to use when reconstructing the
# original time-domain signal.


# proportion of frequencies (from 0-srate) to reconstruct (.5 is Nyquist)
propfrex = .5

# set parameters
srate = 1000
time  = np.arange(0, 3, 1/srate)
pnts  = len(time)

# create multispectral signal
signal  = np.multiply(
    (1 + np.sin(2 * np.pi * 12 * time)),  
    np.cos(np.sin(2 * np.pi * 25 * time) + time)
    )

# prepare the Fourier transform
fourTime = np.arange(0, pnts)/pnts
fCoefs   = np.zeros(len(signal), dtype=complex)

# here is the Fourier transform...
for fi in range(0,pnts):
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    fCoefs[fi] = np.sum( np.multiply(signal,csw) ) / pnts

fig, axs = plt.subplots(2, 1)

# Plot the signal on the frequency domain using a gradient
hz = np.linspace(0, srate, num=pnts)
amplitude = 2 * np.abs(fCoefs)

# Create the line collection from the coordinates
points = np.expand_dims(np.stack([hz, amplitude], axis=1), axis=1)
segments = np.hstack([points[:-1], points[1:]])
lc = LineCollection(segments)
lc.set_array(hz)

# add the collection to the ax and st up the ax limits
axs[0].add_collection(lc);
axs[0].set_title("Frequency domain")
axs[0].set_ylim(0, amplitude.max())
axs[0].set_xlim(0, hz.max())
axs[0].set_xticks(np.arange(0, int(srate/2) + 1, 100))
axs[0].set_xlabel("Frequency (Hz)")

# initialize the reconstructed signal
reconSignal = np.zeros(pnts, dtype=complex)

# inverse Fourier transform here
for fi in range(pnts):#int(propfrex*pnts)):
    
    # create coefficient-modulated complex sine wave
    csw = fCoefs[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    
    # sum them together
    reconSignal += csw

    if fi in [10, 1500, 2999]:

        axs[1].plot(
            time,
            np.real(reconSignal),
            zorder=-fi,
            color=plt.cm.viridis(fi/(pnts-1)),
            label=r"n$^{\circ}$" + str(fi))
        #print(colors[fi])

axs[1].legend(title="Reconstructed with frequencies up to...", ncols=3)
axs[1].set_title("Time domain")
axs[1].set_xlim(time[0], time[-1])
axs[1].set_xlabel("Time (s)")

fig.tight_layout()
```

# Inverse Fourier transform for signal processing


As previously stated, the application of many signal processing algorithms is
more efficient on the time domain. For example, in the case of band-stop
filtering we take transform the signal, change the amplitudes or the phase
values in the frequency domain, and then compute the inverse Fourier transform
to get back to the time domain. Note this procedure is useful only when there
are clearly spectral separable components in the signal.

## Python

First we create a signal with a pair of two sine waves at 4 and 10 hertz and
compute the Fourierr Transform.

```{python}
srate = 1000
time  = np.arange(0,2-1/srate,1/srate)
pnts  = len(time)

# signal 
signal = np.sin(2*np.pi*4*time) + np.sin(2*np.pi*10*time)


# Fourier transform
fourTime = np.array(np.arange(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(0,pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )/pnts


# frequencies in Hz
hz = np.linspace(0,srate/2,int(np.floor(pnts/2.0)+1))

# now plot
plt.plot(time,signal)
plt.title('Original signal, time domain')
plt.show()
```

And then here I'm going to compete the inverse Fourier transform and then make some plots.

So first, let me show you what the original plot looks like.

So I'm going to run this code.

And I don't care about this stuff, I just want to show you what the original signal looks like.

And I'll also show you the

original amplitude spectrum.

All right, so here we have our signal.

It's a combination of a four hertz and a 10 hertz sine wave.

So it's two sine waves, summed on top of each other.

And that you see perfectly accurately reconstructed in the

amplitude spectrum here in this plot.

Now, what I want to do is eliminate the 10 hertz frequency component from this spectrum, so that we

get a pure sine wave at four hertz.

That's going to be the goal.

And the mechanism, the way that I'm going to do that, is by taking the Fourier coefficients from the

forward Fourier transform.

Then I'm going to identify the frequency index corresponding to 10 hertz.

That's going to be this component here.

And then I'm going to set that Fourier coefficient to be zero.

So now that I've modulated the Fourier coefficients, I'm going to do a reconstruction using

the inverse Fourier transform. And now I'm not using the original Fourier coefficients, but the modulated

Fourier coefficients, with the coefficient corresponding to the ten hertz component set to zero.

And then we're going to plot that and see what that looks like.

All right.

So now I'm going to run this entire cell and we can take a look.

So here's the original signal.

This is the amplitude spectrum of the original signal, and now here is the band-stopped filtered signal.

So you might be a little bit confused and perhaps a little bit disappointed because I said that our

goal was to reconstruct exactly the four hertz component without the 10 Hertz component.

But when you look at this, this is clearly not a pure sine wave.

In fact, it looks an awful lot like this original signal.

But these faster sine waves are

dampened. They're a little bit smaller in amplitude compared to what they are here.

I encourage you to pause the video and see if you can figure out what went wrong here. What's wrong

in the code, and why we still have a ten hertz component here.

So it turns out that what went wrong here is that I didn't account for the fact that the amplitude of

this

10 hertz component is split between the positive frequencies and the negative frequencies.

So, in fact, what I've done here is zero out the positive frequency, but I did not zero out the negative

frequency, the corresponding negative frequency for 10 hertz.

So that means that I only actually attenuated the ten hz signal.

I got rid of half of its amplitude.

Half of its amplitude was still in the negative frequency.

So let me do that.

Let me get rid of the corresponding negative frequency.

So that's going to be fCoefModulated.

And now I want the...

So I want to go from the end, so the negative frequency is going to be from the end minus freqidx.

And then we have to add this plus two here.

So this plus two is actually just a matlab indexing.

Normally it would be a plus one for typical indexing.

However, you also have to account for the DC component.

For the DC component is the first element in the positive frequencies.

But remember that the negative frequencies don't have a zero hertz component, so therefore we have

to add an additional offset to the negative frequencies going backwards to account for this DC component

here.

I realize that's a little bit confusing, but this is just something about programming and indexing.

This is not really about the Fourier transform.

The important thing about the Fourier transform is that I'm also setting to zero the Fourier coefficient

corresponding to minus 10 hertz.

OK, and now I'm going to run this whole cell again.

And now you see, we don't see any 10 hertz component in the reconstructed signal.

There's only a four Hertz component.

Now, from this example, you can see why this procedure is appropriate only for signals that have clearly

spectrally separable components. If these two components of the signal

overlapped in the frequency domain, then simply removing some frequencies is not going to isolate one

part of the signal.

Now, one important word of warning: This procedure, where I just zeroed out one Fourier coefficient,

can introduce artifacts in the time domain signal. So typically you would not want to just set some

Fourier coefficients exactly to zero.

Typically, you would want to have some kind of gentle slope instead of a hard edge.

I'll show why that's the case in the section about the effects of non-stationarity, and in my course

on signal processing I talk a lot more about optimal design and appropriate design of low pass filters

and high pass filters, band-stop filters and band-pass filters.

In this case, this very hard edge filter happens to work really well because the signal contains only

pure sine waves.

In this video, I showed you an application of using the inverse Fourier transform to suppress one spectral

feature of a signal while leaving another spectral feature untouched.

This shows the usefulness of the inverse Fourier transform for signal processing applications.

```{python}
# find the coefficient for 10 Hz
freqidx = np.argmin(np.abs(hz-10))

# set that coefficient to zero
fCoefsMod = list(fCoefs)
fCoefsMod[freqidx] = 0
# fCoefsMod[-freqidx] = 0
fCoefsMod[len(fCoefsMod)-freqidx] = 0 


# and compute inverse
reconMod = np.zeros(len(signal),dtype=complex)
for fi in range(0,pnts):
    csw = fCoefsMod[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    reconMod = reconMod + csw

# plot original amplitude spectrum
plt.stem(hz,2*np.abs(fCoefs[0:len(hz)]))
plt.xlim([0,25])
plt.title('Original signal, frequency domain')
plt.show()

# and plot modulated time series
plt.plot(time,np.real(reconMod))
plt.title('Band-stop filtered signal, time domain')
plt.show()

```