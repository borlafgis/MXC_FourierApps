# Code for Section 4: The discrete inverse Fourier transform

```python
import numpy as np
import math
import matplotlib.pyplot as plt
import pylab as pl
from IPython import display
import time as ttime
import random
from mpl_toolkits.mplot3d import Axes3D
```


## Inverse discrete Fourier transform

The forward Fourier transform uses complex sine waves to convert signals from
the time domain, to the frequency domain. The result is a series of Fourier coefficients depicting with which which amplitude and phase the signal best
matches the complex sine wave corresponding to each frequency.

The inverse fourier transform is the opposite process. The complex Fourier
coefficients already depict the frequencies of the the complex sine waves.
Thus, it is just a matter of looping applying some steps for each:

1. Create a complex sine wave with the same number of time points as the signal and a frequency defined by point-1.

2. Multiply that sine wave by the complex Fourier coefficient (the coefficient that you obtained with the forward Fourier transform).

3.Sum the modulated (and multiplied) complex sine waves together.

After this whole procedure, the result will be exactly the original signal that you started with.

So you can think of these complex sine waves like templates.

These are like template sine waves, and then you have to modulate them by a specific amplitude and

a specific phase given by the complex Fourier coefficients.

Let's take a look in Matlab.

Here, I'm creating a signal, you can see it's a sum of two sine wave, a sine wave at four

hertz, a sine wave at six point five hertz.

This is the forward Fourier transform.

So this is all code you've seen before in the previous section.

So I'll just plot this.

And now here in this cell, we get to the inverse Fourier transform.

So here I'm initializing the vector for the reconstructed signal.

Here I'm looping over time points, which is going to correspond to frequencies.

Here I create the complex sine wave, so this is the template sine wave, you can see that it's e to

the i two pi f t. And this complex sine wave looks an awful lot like this complex sine wave from the

forward Fourier transform.

The only difference, which you will notice here, is the minus sign.

So here was the minus sign and here there is no minus sign.

I'm going to talk about this in a minute.

But then we take this complex sine wave as a template, multiply it by the complex Fourier coefficients,

and this was the output of the forward Fourier transform.

So this is the modulation of the template complex sine wave by the complex Fourier coefficient.

And then we sum all of these together.

So I'm summing the reconstructed signal onto itself and then I add to that this modulated complex sine

wave.

And that's basically all there is to it.

So let me run this cell here you see in blue, this blue line here...

Let me zoom in here....

So the blue line here corresponds to the original signal, the signal that I generated up here,

and the red line is the reconstruction from the inverse Fourier transform.

And you can see that they match quite well.

In fact, they match perfectly.

Now, one key difference between the forward and inverse Fourier transform is the minus sign, as I

just mentioned.

You need the minus sign in one of them so that the imaginary coefficients will cancel in the inverse.

That's because I mentioned in a few videos ago, in the previous section, about the cosine identity and

how you need a positive complex exponential and a negative complex exponential to sum in order

to create a real-valued cosine wave.

So the negative sign goes in the forward Fourier transform and the positive sign goes in

the inverse Fourier transform.

And together, those will reconstruct the original signal by canceling out all of the imaginary components.

Essentially, it's imposing a phase shift into the inverse Fourier transform.

Another thing I would like to point out is this function real; I'm taking the reconstructed signal

and putting it into the function real.

Now, the thing is that there really isn't an imaginary component in here; it's all real valued.

However, there are some tiny computer rounding errors that cause a very, very small near zero imaginary

component for some of these sine waves that go back into the reconstructed signal.

Typically at or near the Nyquist frequency. So we can see this,

So first of all, we can see... whos reconSignal.

So it actually is a complex signal.

But if I plot the time by the real part of the reconSignal and then I plot time by the imaginary part

of the reconSignal.

Then you can see this is the real part of the signal, and this basically matches what I have here.

Here's the imaginary part of the signal, which is really just a flat line.

And I guess if you would zoom in.

It's possible that at some point.

You might actually see some tiny, tiny fluctuations in the imaginary part of the signal.

So here I am at ten to the minus eight and this is still a flat line.

All right, so now zooming in, you can finally see these computer rounding errors at the scale of 10

to the minus 12, compared to the scale of the data, which is ten to the one or ten to the zero.

I would like to show you the inverse Fourier transform in a different way.

Now, this is going to be in an animation which I think will highlight the picture, the concept, that

the inverse Fourier transform is building up the signal one frequency at a time in this loop.

OK, so what I'm going to do is create this rather bizarre looking multispectral signal.

You can see it's a pretty weird signal, has a sine embedded in the cosine, for example.

So here I compute the Fourier transform of this signal, and here I'm setting up a movie. And actually I

think I'll run the movie and then I'll talk about it as it's playing.

So here in blue, you see the original signal, and in black you see this kind of jumpy, wavy line.

And what we're doing here is reconstructing the original signal, one frequency at a time, using the

inverse Fourier transform.

And here you see the amplitude spectrum being built up over time, one frequency at a time.

And as these frequencies are updating in this plot, they're also being added to this time course here.

So as time goes on, which means we're adding more and more of the frequencies, you see the black line

will match closer and closer to the blue line.

Now, finally, we've gone through all of the frequencies and so we've reconstructed the signal perfectly.

So here is the loop that goes over the inverse Fourier transform.

Now this part of the loop is exactly the same thing that I showed up here.

This inverse Fourier transform.

The only difference, or the only additions here, is that I'm adding this plotting code here.

And basically this plotting code is updating this amplitude spectrum and it's updating the time domain

plot as it's being plotted for each additional frequency in the inverse Fourier transform.

So I'll run this again and there's one thing that I would like to point out explicitly.

Well, first of all, it's really neat.

It's fun to watch.

So it looks like it's really jumpy.

But that's just because these frequencies are a bit discrete in here.

So there are these frequency peaks in here and each time it gets to the peak, it looks like it's jumping.

OK, so I'm actually going to cancel this here.

And what I would like to point out is that you can see we've reconstructed all of the positive

frequencies and we haven't yet gotten to the negative frequencies down here.

And then you can see that the signal, the reconstructed signal in black, looks an awful lot like the

blue line, but it's not quite complete.

It looks like it's around half of the amplitude.

And in fact, what's happening is that it really is just half the amplitude because we haven't yet gotten

to the negative frequencies.

In this video, I showed you how to compute the inverse Fourier transform. Once you already have the

Fourier coefficients from the forward Fourier transform.

The important thing to remember is that the inverse Fourier transform provides a perfect reconstruction

of the original signal, provided that you didn't change any of the Fourier coefficients.

You might wonder what the purpose of the inverse Fourier transform is. If going from the time domain

to the frequency domain provides unique and important insights into rhythmicity of signals,

then what is the point of applying the inverse Fourier transform to get back into the time domain? Particularly

considering that the inverse Fourier transform is a perfect reconstruction of the original signal.

The importance of the inverse Fourier transform comes from its use as a tool in signal processing.

The idea is that many signal processing algorithms, such as convolution, filtering, and cross correlation,

can be done faster and more efficiently in the frequency domain.

Therefore, many signal processing techniques involve applying the forward Fourier transform,

applying some signal processing algorithms on the Fourier coefficients, and then applying the inverse Fourier

transform to get back to the time domain. I talk about this a lot more in my course on digital signal

processing.

And I will also include, in this course, several specific examples in the section on applications of the

Fourier Transform.





```python
## first, the forward Fourier transform

# create the signal
srate  = 1000 # hz
time   = np.arange(0,2.,1/srate)  # time vector in seconds
pnts   = len(time) # number of time points
signal = 2.5 * np.sin( 2*np.pi*4*time ) + 1.5 * np.sin( 2*np.pi*6.5*time )


# prepare the Fourier transform
fourTime = np.array(np.arange(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(0,pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )

# extract amplitudes
ampls = np.abs(fCoefs) / pnts
ampls[range(1,len(ampls))] = 2*ampls[range(1,len(ampls))]

# compute frequencies vector
hz = np.linspace(0,srate/2,num=math.floor(pnts/2)+1)

plt.stem(hz,ampls[range(0,len(hz))])
plt.xlim([0,10])
plt.show()
```


```python
## the inverse Fourier transform

# initialize time-domain reconstruction
reconSignal = np.zeros(len(signal));

for fi in range(0,pnts):
    
    # create coefficient-modulated complex sine wave
    csw = fCoefs[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    
    # sum them together
    reconSignal = reconSignal + csw


# divide by N
reconSignal = reconSignal/pnts

plt.plot(time,signal,label='original')
plt.plot(time,np.real(reconSignal),'r.',label='reconstructed')
plt.legend()
plt.show() 

# note: signals are entire overlapping. you can try zooming in
```


```python
## partial reconstruction of signal
# this differs from the MATLAB code because in-loop graphics updating 
# in python is version- and platform-dependent. Instead, here you can
# specify the proportion of frequencies to use when reconstructing the
# original time-domain signal.


# proportion of frequencies (from 0-srate) to reconstruct (.5 is Nyquist)
propfrex = .5

# set parameters
srate = 1000
time  = np.arange(0,3,1/srate)
pnts  = len(time)

# create multispectral signal
signal  = np.multiply( (1+np.sin(2*np.pi*12*time)) , np.cos(np.sin(2*np.pi*25*time)+time) )

# prepare the Fourier transform
fourTime = np.array(range(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

# here is the Fourier transform...
for fi in range(0,pnts):
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    fCoefs[fi] = np.sum( np.multiply(signal,csw) ) / pnts


# frequencies in Hz (goes up to srate just as a coding trick for later visualization)
hz = np.linspace(0,srate,num=pnts)

# initialize the reconstructed signal
reconSignal = np.zeros(len(signal),dtype=complex)

# inverse Fourier transform here
for fi in range(0,pnts):#int(propfrex*pnts)):
    
    # create coefficient-modulated complex sine wave
    csw = fCoefs[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    
    # sum them together
    reconSignal = reconSignal + csw
    
    if fi<300 or fi>2700:
        # set up plot
        pl.cla() # wipe the figure
        plt.subplot2grid((2,1),(0,0))
        plt.plot(time,signal,label='Original')
        plt.plot(time,np.real(reconSignal),label='Reconstruction')
        plt.legend()
        
        plt.subplot2grid((2,1),(1,0))
        plt.plot(hz[0:fi],2*np.abs(fCoefs[0:fi]))
        plt.xlim([0,hz[-1]])

        # show plot
        display.clear_output(wait=True)
        display.display(pl.gcf())
        ttime.sleep(.01)

```

---
# VIDEO: Inverse Fourier transform for signal processing
---



```python
## bandpass filter

# simulation params
srate = 1000
time  = np.arange(0,2-1/srate,1/srate)
pnts  = len(time)

# signal 
signal = np.sin(2*np.pi*4*time) + np.sin(2*np.pi*10*time)


# Fourier transform
fourTime = np.array(np.arange(0,pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(0,pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )/pnts


# frequencies in Hz
hz = np.linspace(0,srate/2,int(np.floor(pnts/2.0)+1))

# find the coefficient for 10 Hz
freqidx = np.argmin(np.abs(hz-10))

# set that coefficient to zero
fCoefsMod = list(fCoefs)
fCoefsMod[freqidx] = 0
# fCoefsMod[-freqidx] = 0
fCoefsMod[len(fCoefsMod)-freqidx] = 0 


# and compute inverse
reconMod = np.zeros(len(signal),dtype=complex)
for fi in range(0,pnts):
    csw = fCoefsMod[fi] * np.exp( 1j*2*np.pi*fi*fourTime )
    reconMod = reconMod + csw



# now plot
plt.plot(time,signal)
plt.title('Original signal, time domain')
plt.show()

# plot original amplitude spectrum
plt.stem(hz,2*np.abs(fCoefs[0:len(hz)]))
plt.xlim([0,25])
plt.title('Original signal, frequency domain')
plt.show()

# and plot modulated time series
plt.plot(time,np.real(reconMod))
plt.title('Band-stop filtered signal, time domain')
plt.show()

```


```python
len(fCoefsMod)
```
