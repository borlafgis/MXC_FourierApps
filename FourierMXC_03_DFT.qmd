# The discrete Fourier transform

```{python}
import numpy as np
import math
import matplotlib.pyplot as plt
import scipy.fftpack
import random
from mpl_toolkits.mplot3d import Axes3D
```

## the DFT works

### Pseudocode for the DFT

Create a loop going through each point in the signal. For each iteration $i$,
create a complex sine wave with the same length as the signal, and a frequency
defined as $i-1$. Then, calculate the dot product between the wave and the
signal. The result is called a **Fourier coefficient**, from which it is
possible to extract the amplitude of the angle relative to the positive real
axis, as well as the magnitude. The latter represents the signal amplitude for
each frequency, which can be squared to obtain their powers.

## Python

The first step is to simulate a signal as the sum two sine waves, one at $4$
hertz, with an amplitude of $2.5$ and the another other at $6.5$ hertz, with
an amplitude of $1.5$ and this sine wave has an amplitude of two point five.
Simulating data is useful for learning the methodologies because you know the
signal that was generated, making the outcome easier to predict.

```{python}
# create the signal
srate  = 1000 # hz
time   = np.arange(0.,2.,1/srate) # time vector in seconds
pnts   = len(time) # number of time points
signal = 2.5 * np.sin( 2*np.pi*4*time ) + 1.5 * np.sin( 2*np.pi*6.5*time )
```

Then we create a vector holding the complex sine waves ranging from 0 to near-1.
Notice the count only reaches the length of the signal minus on before dividing
by the length of the signal (number of time points). This may seem like an odd
detail, but it is important to ensure the time vector is normalized like this
[SEE VIDEO ABOUT NORMALIZATION]. We also prepare an output vector with the same
length as the signal, where we will place the fourier coefficients.

```{python}
# prepare the Fourier transform
fourTime = np.array(range(pnts))/pnts
fCoefs   = np.zeros((len(signal)),dtype=complex)
```

For each iteration within the loop we take the $i^{th}$ frequency in `NAME` and
use it to create a complex sine wave (`csw`). Once we have the signal we can
calculate the dot product between the original sinal and the complex wave we
just have generated.

This dot product is the reason why the normalized time needs to have the same
number of points as the original signal: otherwise we would not be able to
compute a valid product between the sine wave and the signal.

```{python}
for fi in range(pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    # these are called the Fourier coefficients
    fCoefs[fi] = np.sum( np.multiply(signal,csw) ) / pnts
```

~~Note this means the number of frequencies of the Fourier transform is controlled by the number of points in the signal!. There are several important aspects to the Fourier transform that you need to know about, but that will have to wait because there are other aspects that you need to learn first.~~

After completing the loop we have a fourier coefficient per frequency. Now we
can extract the magnitude, the distance of each coefficient away from the $0$.
To obtain the signal amplitude in the units of the original signal requires
multiplying the magnitude by two [SEE OTHER VIDEO].

Now we plot the amplitude spectrum from our Fourier transform here. The time
domain looks like [MAKE PLOT], whereas the amplitude in the frequency domain
looks like:

```{python}
# extract amplitudes
ampls = 2*np.abs(fCoefs)

# compute frequencies vector
hz = np.linspace(0,srate/2,int(math.floor(pnts/2.)+1))

plt.stem(hz,ampls[range(len(hz))])
plt.xlabel('Frequency (Hz)'), plt.ylabel('Amplitude (a.u.)')
plt.xlim(0,10)
plt.show()

```

Most of the Fourier coefficients are zero, except for $4$ and $6.5$, the two
frequencies of the waves we added to generate the signal.

An important detail about this visualization is that using a line-plot to show
the results of a Fourier transform is not fully correct because the drawing a
line implies we know the amplitude between points. However, it is not possible
to measure what the signal looks like with an infinite level of detail, we only
know is value at specific frequencies. Thus, it is more correct to use a stem
plot or a bar plot to convey the results of a Fourier transform.

We can also compare these results with the output of the fast Fourier transform
FFT function: we apply the function, and extract the amplitudes from the
Fourier coefficients. As we can see the result of the function and the
loop-based result overlap. This is not a rigorous proof that these procedures
are accurate, but the convergent results do provide evidence that we're doing
the right thing here, because I think we can all agree to trust the Numpy FFT
code.

## Second plot

The last plot was just a way to represent information contained in the Fourier
coefficients. Now I'm going to plot two Fourier coefficients at $4$ and $4.5$
hertz. For this, I need to find the two indices in the frequency vector that
correspond to these two frequencies [SEE NEXT VIDEO]. [...] For now, you can
just assume that this is a vector that converts from frequencies in indices to
frequencies in Hertz, given our sampling rate and given the length of time of
the signal. Now I extract the magnitude and the angle of the coefficients and
plot them on the complex plane (real axis, $x$, imaginary axis $y$). Larger 
distances from the origin (magnitude) indicate the signal is more similar to
a sine wave at that specific frequency. Thus, $4.5$, a frequency appearing in
the signal is away from the origin.

If the dot product is really close to the origin, then it means that the signal
and the sine wave at this frequency are close to orthogonal, which means that
the signal looks nothing like the sine wave at that frequency. So $4$ is very
close to $0$

When doing this kind of analysis, usually we are not interested in the exact
phase relationship between the signal and the sine wave, so generally only
magnitudes are shown. However, note phase angles also important important,
as they are crucial for applying the inverse Fourier transform.

## Summary

The discrete time Fourier transform works by computing the complex dot product
between the signal and a series of complex sine waves at different frequencies.

```{python}
## plot two Fourier coefficients

coefs2plot = [0,0]
coefs2plot[0] = np.argmin(np.abs(hz-4))
coefs2plot[1] = np.argmin(np.abs(hz-4.5))

# extract magnitude and angle
mag = np.abs(fCoefs[coefs2plot])
phs = np.angle(fCoefs[coefs2plot])


# show the coefficients in the complex plane
plt.plot( np.real(fCoefs[coefs2plot]) , np.imag(fCoefs[coefs2plot]) ,'o',
         linewidth=2,markersize=10,markerfacecolor='r')

# make plot look nicer
plt.plot([-2,2],[0,0],'k',linewidth=2)
plt.plot([0,0],[-2,2],'k',linewidth=2)
axislims = np.max(mag)*1.1
plt.grid()
plt.axis('square')
plt.xlim([-axislims, axislims])
plt.ylim([-axislims, axislims])
plt.xlabel('Real axis')
plt.ylabel('Imaginary axis')
plt.title('Complex plane')
plt.show()
```

# VIDEO: Converting indices to frequencies

The goal of this video is to learn how to transform sine wave frequencies
from arbitrary indices into a meaningful metric like Hertz.

In the previous video, I computed the Fourier transform of a signal that
contained two sine wave components. You could confirm by looking at the graph
that the non-zero components were at the same frequencies as the simulated
signal.

But how did the Fourier transform know that I was using units of Hertz?
The time vector used to create these sine waves in the Fourier transform was
normalized, these were not in units of seconds, it just went from zero to one
(or slightly less than one) and nowhere inside the Fourier transform loop
did I specify the sampling rate.

Instead, what I did was create a meaningful vector of frequencies in Hertz,
in a line of code that looked like this, and this was done after the Fourier
transform was complete.

`hz = np.linspace(0, srate/2, np.floor(pnts/2) + 1)`

So what does this line mean and why does it correctly convert arbitrary indices
into a meaningful vector of Hertz?

That is the main topic of this video.

In the process, you will also learn about the Nyquist frequency, which defines the fastest frequency in a signal that you can measure.

## Pyhon

Here we have a loop that is very similar to the Fourier transform: the time
vector, the loop over points, and the complex sine wave are all in here, but
there's no signal, and there's no product.

Formally, this is not formally a Fourier transform. However, the complex sine
wave is the same one that is used for the transform. Visualizing it will allow
us to examine its properties.

Within the loop, the frequency of the sine wave is defined by the looping
index minus one. Then, we just plot the real and imaginary parts of the
complex sine wave, cosine and sine, respectively.


```{python}

pnts     = 16 # number of time points
fourTime = np.array(range(pnts))/pnts

for fi in range(pnts):
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # and plot it
    
    loc = np.unravel_index(fi,[4, 4],'F')
    plt.subplot2grid((4,4),(loc[1],loc[0]))
    plt.plot(fourTime,np.real(csw))
    plt.plot(fourTime,np.imag(csw))

plt.show()
```


The plot represent the real and the imaginary part of the complex sine wave
for each step in the loop. When the index is one, the complex sine wave is constructed using a frequency of `fi - 1`, which actually means $0$ for the
first iteration. Then the exponent is $0$, and we have $e^{0}$, so the real
part is just one: a flat line. It may not look as a sine wave, but it is: a
wave with a frequency of $0$. It is the average value of all the data points
in the signal, capturing any global offsets in the signal. It is called the
DC component, or DC Offset, where DC stands for Direct Current.

~~I'll show several examples and discuss this more detail in a separate video.~~

But for now, the important thing to know is that the first frequency in the Fourier transform is the

zero frequency, which is a sine wave of a flat line.

So zero frequency in any units is still zero, so we might as well call this zero hertz.

Here you can see the frequency is getting faster and faster, so the sine waves are going faster and

faster.

I'm actually now going to switch back to the slides and we'll come back to Matlab in a few minutes.

So as the sine waves get faster with respect to the sampling rate,

The number of measurement points per cycle decreases, and eventually we get to a situation like this,

where we have a sine wave that's fluctuating so quickly, we only have two measurement points per cycle,

one corresponding to the peak and one corresponding to the trough.

If this sine wave were going any faster, or if the measurement samples were any slower, it would not

be possible to measure this sine wave accurately. That would produce something called aliasing.

And I'm going to have a separate video that's all about this topic: aliasing and the implications of

aliasing.

Here you can see that even if you have two measurement points per cycle, it's not just any two arbitrary

points.

The points have to be appropriately placed along the sine wave in order to capture these fluctuations.

So you can think of 2 points per sample more as a theoretical limit.

It's important to realize that the density of the sampling here is defined by the sampling rate of the

data, so therefore the fastest frequency that you can measure is one half of the sampling rate, which

corresponds to two measurement points per cycle.

This is also called the Nyquist Frequency and is defined as one half of the sampling rate.

So if you have measurement samples every millisecond, that corresponds to a 1000 hertz or one kilohertz

sampling rate, and then the Nyquist frequency would be 500 hertz.

Now we can see this in more detail in Matlab. So here these sine waves in the Fourier transform are

getting faster and faster.

Here we have the frequency index of eight, which corresponds to one half of the number of time points.

So this would correspond to the Nyquist frequency here.

We're actually getting sine waves that are faster than the Nyquist frequency, and these end up being

aliased into lower frequencies.

Now, these frequencies are called the negative frequencies, and that is the topic of a separate video.

Each positive frequency has a corresponding negative frequency, and it's interesting to note that the

real part of the complex sine waves for the positive frequencies match the real part of the complex

sine waves for the negative frequencies, and the imaginary part of the complex sine waves are shifted

by minus pi.

Again, I will talk more about that in a subsequent video.

The point here is that we only interpret the frequencies between and including Zero and Nyquist.

That gives us a total of N over two plus one frequencies that are evenly spaced between zero and Nyquist.

So the N/2+1 comes from N/2 positive frequencies starting here, plus one extra

for the DC and that starts here.

So for this reason, in order to convert from arbitrary indices that you get here resulting from the

looping index of the Fourier transform into a vector of frequencies in Hertz, you generate a vector

that starts from zero and ends at the Nyquist frequency, and it takes N/2+1 steps to go

between them.

And that's what you see in the code that I showed in the previous video.

Let's see... that was here.

So I specify a vector of hertz that goes from zero to the Nyquist frequency, which is defined by the

sampling rate divided by two.

And here is N/2+1.

So we have N/2+1 frequencies between just above zero and Nyquist.

And then we add one additional frequency for the zero hertz, or the DC component.

So in this video, I showed you how to convert from arbitrary indices into meaningful units of the data

sampling rate.

I also explained in a little more detail about the frequencies and the complex signals that are used

in the Fourier transform.

In the next video, I'll talk more about these mysterious positive and negative frequencies.




# VIDEO: Converting indices to frequencies, part 2

---




```python
## code from the slides

srate = 1000
npnts = 100001

# frequencies vector
if npnts%2==0:
  topfreq = srate/2
else:
  topfreq = srate/2 * (npnts-1)/npnts

hz1 = np.linspace(0,srate/2,np.floor(npnts/2+1).astype(int))
hz2 = np.linspace(0,topfreq,np.floor(npnts/2+1).astype(int))

# some arbitary frequency to show
n = 16
print('%.9f\n%.9f'%(hz1[n],hz2[n]))

```

# VIDEO: Shortcut: Converting indices to frequencies



```python
## Case 1: ODD number of data points, N is correct

# create the signal
srate = 1000
time  = np.arange(0,srate+1)/srate
npnts = len(time)

# Notice: A simple 15-Hz sine wave!
signal = np.sin(15*2*np.pi*time)

# its amplitude spectrum
signalX = 2*np.abs(scipy.fftpack.fft(signal)) / len(signal)

# frequencies vectors
hz1 = np.linspace(0,srate,npnts+1)
hz2 = np.linspace(0,srate,npnts)


# plot it
fig = plt.subplots(1,figsize=(10,5))
plt.plot(hz1[:npnts],signalX,'bo',label='N+1')
plt.plot(hz2,signalX,'rs',label='N')
plt.xlim([14.9,15.1])
plt.ylim([.99,1.01])
plt.legend()
plt.xlabel('Frequency (Hz)')
plt.title(str(len(time)) + ' points long')
plt.ylabel('Amplitude')
plt.show()

```


```python
## Case 2: EVEN number of data points, N+1 is correct

# create the signal
srate = 1000
time  = np.arange(0,srate)/srate
npnts = len(time)

# Notice: A simple 15-Hz sine wave!
signal = np.sin(15*2*np.pi*time)

# its amplitude spectrum
signalX = 2*np.abs(scipy.fftpack.fft(signal)) / len(signal)

# frequencies vectors
hz1 = np.linspace(0,srate,npnts+1)
hz2 = np.linspace(0,srate,npnts)


# plot it
fig = plt.subplots(1,figsize=(10,5))
plt.plot(hz1[:npnts],signalX,'bo',label='N+1')
plt.plot(hz2,signalX,'rs',label='N')
plt.xlim([14.9,15.1])
plt.ylim([.99,1.01])
plt.legend()
plt.xlabel('Frequency (Hz)')
plt.title(str(len(time)) + ' points long')
plt.ylabel('Amplitude')
plt.show()

```


```python
## Case 3: longer signal

# create the signal
srate = 1000
time  = np.arange(0,5*srate)/srate
npnts = len(time)

# Notice: A simple 15-Hz sine wave!
signal = np.sin(15*2*np.pi*time)

# its amplitude spectrum
signalX = 2*np.abs(scipy.fftpack.fft(signal)) / len(signal)

# frequencies vectors
hz1 = np.linspace(0,srate,npnts+1)
hz2 = np.linspace(0,srate,npnts)


# plot it
fig = plt.subplots(1,figsize=(10,5))
plt.plot(hz1[:npnts],signalX,'bo',label='N+1')
plt.plot(hz2,signalX,'rs',label='N')
plt.xlim([14.99,15.01])
plt.ylim([.99,1.01])
plt.legend()
plt.xlabel('Frequency (Hz)')
plt.title(str(len(time)) + ' points long')
plt.ylabel('Amplitude')
plt.show()

```

# VIDEO: Normalized time vector


```python
# create the signal
srate  = 1000 # hz
time   = np.arange(0,2*srate)/srate # time vector in seconds
pnts   = len(time) # number of time points
signal = 2.5 * np.sin( 2*np.pi*4*time ) + \
         1.5 * np.sin( 2*np.pi*6.5*time )


# show the original signal
plt.plot(time,signal,'k')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Time domain')
plt.show()
```


```python
# prepare the Fourier transform
fourTime = np.arange(0,pnts)/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(pnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    # these are called the Fourier coefficients
    fCoefs[fi] = sum( signal*csw ) / pnts

# extract amplitudes
ampls = 2*abs(fCoefs)
```


```python
# compute frequencies vector
hz = np.linspace(0,srate/2,int(np.floor(pnts/2)+1))

# plot amplitude
plt.stem(hz,ampls[:len(hz)],'ks-')

# make plot look a bit nicer
plt.xlim([0,10])
plt.ylim([-.01,3])
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude (a.u.)')
plt.title('Amplitude spectrum')
plt.show()


# plot angles
plt.stem(hz,np.angle(fCoefs[:len(hz)]),'ks-')

# make plot look a bit nicer
plt.xlim([0,10])
plt.ylim([-np.pi,np.pi])
plt.xlabel('Frequency (Hz)')
plt.ylabel('Phase (rad.)')
plt.title('Phase spectrum')
plt.show()


# finally, plot reconstructed time series on top of original time series
reconTS = np.real(scipy.fftpack.ifft( fCoefs ))*pnts

plt.plot(time,signal,'k',label='Original')
plt.plot(time[::3],reconTS[::3],'r.',label='Reconstructed')
plt.legend()
plt.show()
```


---
# VIDEO: Scaling Fourier coefficients
---



```python
## incorrect amplitude units without normalizations

# create the signal
srate  = 1000 # hz
time   = np.arange(0.,1.5,1/srate)  # time vector in seconds
pnts   = len(time)   # number of time points
signal = 2.5 * np.sin( 2*np.pi*4*time )


# prepare the Fourier transform
fourTime = np.array(range(pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(pnts):
    # create complex sine wave and compute dot product with signal
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )


# extract amplitudes
ampls = np.abs(fCoefs);

# compute frequencies vector
hz = np.linspace(0,srate/2,num=int(math.floor(pnts/2.)+1))

plt.stem(hz,ampls[range(len(hz))])
plt.xlabel('Frequency (Hz)'), plt.ylabel('Amplitude (a.u.)')
plt.xlim(0,10)
plt.show()
```


---
# VIDEO: Phase (this is the code used to generate the plots in the video)
---



```python
## same amplitude, different phase

# simulation parameters
srate = 1000
time  = np.arange(0.,2.,1/srate)
npnts = len(time)

# generate signal
signal1 = 2.5*np.sin(2*np.pi*10*time +   0  ) # different phase values
signal2 = 2.5*np.sin(2*np.pi*10*time + np.pi/2 )


# prepare the Fourier transform
fourTime = np.array(range(npnts)) / npnts
signal1X = np.zeros((len(signal1)),dtype=complex)
signal2X = np.zeros((len(signal2)),dtype=complex)

for fi in range(npnts):
    
    # create complex sine wave
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    
    # compute dot product between sine wave and signal
    # these are called the Fourier coefficients
    signal1X[fi] = np.sum( np.multiply(signal1,csw) ) / npnts
    signal2X[fi] = np.sum( np.multiply(signal2,csw) ) / npnts


# frequencies vector
hz = np.linspace(0,srate/2,num=int(math.floor(npnts/2.)+1))

# extract correctly-normalized amplitude
signal1Amp = np.abs(signal1X[range(len(hz))])
signal1Amp[1:] = 2*signal1Amp[1:]

signal2Amp = np.abs(signal2X[range(len(hz))])
signal2Amp[1:] = 2*signal2Amp[1:]


# now extract phases
signal1phase = np.angle(signal1X[0:len(hz)])
signal2phase = np.angle(signal2X[0:len(hz)])


# plot time-domain signals
plt.subplot2grid((3,2),(0,0))
plt.plot(time,signal1)

plt.subplot2grid((3,2),(0,1))
plt.plot(time,signal2,'k')

plt.subplot2grid((3,2),(1,0))
plt.stem(hz,signal1Amp)
plt.xlim([0,20])

plt.subplot2grid((3,2),(1,1))
plt.stem(hz,signal2Amp)
plt.xlim([0,20])

plt.subplot2grid((3,2),(2,0))
plt.stem(hz,signal1phase)
plt.xlim([0,20])

plt.subplot2grid((3,2),(2,1))
plt.stem(hz,signal2phase)
plt.xlim([0,20])

plt.tight_layout()
plt.show()
```


---
# VIDEO: Averaging Fourier coefficients
---



```python
# simulation parameters
ntrials = 100
srate   = 200 # Hz
time    = np.arange(0,1,1/srate)
pnts    = len(time)


# create dataset
data = np.zeros((ntrials,pnts))
for triali in range(ntrials):
    data[triali,:] = np.sin(2*np.pi*20*time + 2*np.pi*np.random.rand())

# plot the data
for i in range(ntrials):
    plt.plot(time,data[i,:])
plt.plot(time,np.mean(data,axis=0),'k',linewidth=3)
plt.xlabel('Time (sec.)')
plt.ylabel('Amplitude')
plt.title('Time domain')
# plt.xlim([0,.1])

plt.show()

```


```python
# get Fourier coefficients
dataX = scipy.fftpack.fft(data,axis=1) / pnts
hz = np.linspace(0,srate/2,int(np.floor(pnts/2)+1))

# averaging option 1: complex Fourier coefficients, then magnitude
ave1 = 2*np.abs( np.mean(dataX,axis=0) )

# averaging option 2: magnitude, then complex Fourier coefficients
ave2 = np.mean( 2*np.abs(dataX),axis=0 )

# plot both amplitude spectra
plt.stem(hz,ave1[0:len(hz)],'ks-',label='Average coefficients',use_line_collection=True)
plt.stem(hz+.2,ave2[0:len(hz)],'ro-',label='Average amplitude',use_line_collection=True)
plt.xlim([10,30])
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('Frequency domain')
plt.legend()
plt.show()
```


---
# VIDEO: The DC coefficient
---



```python
## incorrect DC reconstruction without careful normalization

# create the signal
srate  = 1000 # hz
time   = np.arange(0.,2.,1/srate) # time vector in seconds
pnts   = len(time) # number of time points
signal =  1.5 + 2.5*np.sin( 2*np.pi*4*time )


# prepare the Fourier transform
fourTime = np.array(range(pnts))/pnts
fCoefs   = np.zeros(len(signal),dtype=complex)

for fi in range(pnts):
    # create complex sine wave and compute dot product with signal
    csw = np.exp( -1j*2*np.pi*fi*fourTime )
    fCoefs[fi] = np.sum( np.multiply(signal,csw) )


# extract amplitudes
ampls = 2*np.abs(fCoefs/pnts);

# compute frequencies vector
hz = np.linspace(0,srate/2,num=int(math.floor(pnts/2.)+1))

plt.stem(hz,ampls[0:len(hz)])
plt.xlim(-.1,10)
plt.xlabel('Frequency (Hz)'), plt.ylabel('Amplitude (a.u.)')
plt.show()

```


---
# VIDEO: Amplitude spectrum vs. power spectrum
---



```python
# simulation parameters
srate = 1000
time  = np.arange(0,.85,1/srate)
npnts = len(time)

# generate signal
signal = 2.5*np.sin(2*np.pi*10*time)

# Fourier transform and frequencies
signalX = scipy.fftpack.fft(signal) / npnts
hz = np.linspace(0,srate/2,int(np.floor(len(time)/2)+1))


# extract correctly-normalized amplitude
signalAmp = np.abs(signalX[0:len(hz)])
signalAmp[1:] = 2*signalAmp[1:]

# and power
signalPow = signalAmp**2


plt.figure(figsize=(12,3))

# plot time-domain signal
plt.subplot2grid((1,3),(0,0))
plt.plot(time,signal)
plt.xlabel('Time (ms)')
plt.ylabel('Amplitude')
plt.title('Time domain')


# plot frequency domain spectra
plt.subplot2grid((1,3),(0,1))
plt.plot(hz,signalAmp,'ks-',label='Amplitude')
plt.plot(hz,signalPow,'rs-',label='Power')

plt.xlim([0,20])
plt.legend()
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude or power')
plt.title('Frequency domain')

# plot dB power
plt.subplot2grid((1,3),(0,2))
plt.plot(hz,10*np.log10(signalPow),'ks-')
plt.xlim([0,20])
plt.xlabel('Frequency (Hz)')
plt.ylabel('Decibel power')

plt.show()
```
