# Aliasing, stationarity and violations

```{python}
import numpy as np
import math
import matplotlib.pyplot as plt
import random
import timeit
import scipy.fftpack
from mpl_toolkits.mplot3d import Axes3D
from scipy import signal
from scipy import interpolate
```

## Aliasing

Real signals (sounds, radio waves) are continuous. However, we quantify them by
taking samples, finite measurements at regular intervals using digital devices 
(amplifiers, ADC boxes). The original signal will be accurately represented if
the measurement sampling rate is higher (faster) than the fluctuations in the
signal, then there's no problem. If the signal fluctuates faster than we sample
it, there will be some loss of information, leading to aphenomenon called
"aliasing".

### Python 0 (not discussed)

Code from a previous video

```{python}
## code for pictures shown in slides

srate = 1000
t  = np.arange(0,3,1/srate)

# Generate the signal
sig = scipy.signal.detrend(
    np.multiply(
        1+np.sin(2*np.pi*2*t),
        np.cos(np.sin(2*np.pi*5*t+np.cumsum(t/30))+t)
        )
    )

# Generate the selection based on the sampling
k = 25 # or 5
selection = np.arange(1, len(t), k)

# Plot
fig, panels = plt.subplots(3, 1, sharex=True)

panels[0].plot(t,sig)

panels[1].plot(t,sig)
panels[1].plot(t[selection], sig[selection],'r.')

panels[2].plot(t[selection], sig[selection])
```

### Python 1

We cannot create a truly analog signal on a computer, so we a simulate
"continuous-like" signal with a very high sampling rate (1 kilohertz). Then we
will sample this "continuous" signal to a measured sampling rate of 6 Hz. Then
we plot the "continuous" and the sampled signal, both in the time (left) and
the frequency domain (right). 

```{python}
## also show in the lecture slides

# simulation params
# simulation params
cont_rate  = 1000
cont_time   = np.arange(0,1,1/cont_rate)
cont_signal = np.sin(2*np.pi*5*cont_time)
cont_len  = len(cont_time)

# Calculate pairwise distances (1000 vs 6 Hz)
sample_rate = 6
distances = np.subtract(
    cont_time.reshape((-1, 1)),
    np.arange(0,1,1/sample_rate).reshape((1, -1))
    )

# Get the indices of the closest samples, pick with them
idx_closest = np.argmin(np.abs(distances), axis=0)
sample_time, sample_signal = cont_time[idx_closest], cont_signal[idx_closest]
sample_len = len(idx_closest)

# plot the time-domain signals
fig, panels = plt.subplots(2, 2, sharex="col", sharey="col")

panels[0, 0].plot(cont_time, cont_signal, label='analog')
panels[0, 0].plot(sample_time, sample_signal, 'mo', label='sampled')
panels[0, 0].set_title('Time domain')
panels[0, 0].legend(loc="lower right")


# plot the power spectrum of the "analog" signal
sigX = 2*np.abs(scipy.fftpack.fft(cont_signal, cont_len)/cont_len)
hz   = np.linspace(0, cont_rate/2, int(np.floor(cont_len/2)+1))
panels[0, 1].stem(hz, sigX[0:len(hz)])
panels[0, 1].set_xlim([0,20])
panels[0, 1].set_title('Amplitude spectrum')


# now plot only the measured signal

panels[1, 0].plot(sample_time, sample_signal, "mo-")
panels[1, 0].set_title('Measured signal')

# and its amplitude spectrum
sigX = 2*np.abs(scipy.fftpack.fft(sample_signal, cont_len)/sample_len)
hz   = np.linspace(0, sample_rate/2,int(np.floor(cont_len/2)+1))

panels[1, 1].plot(hz,sigX[0:len(hz)], color="m")
panels[1, 1].set_xlim([0,20])
panels[1, 1].set_title('Frequency domain of "analog" signal');
```

The blue line is the "continuous" signal and the magenta dots show the
measurement points at six hertz, which represent what we would reconstruct in
our computer. It is easy to notice that the reconstructed signal is clearly not
representative of what the real signal. Even worse, the amplitude spectrum of
the sampled signal shows high energy and 1 and 2 Hz, with nothing whatsoever at
5 Hz. This happens because the signal fluctuates at 5 Hz, faster the Nyquist
frequency (3 Hz) defined by our sampling rate (6 Hz). We could increase
the sampling frequency to 10 Hz, but even then the 5 Hz peak on the amplitude
spectrum remains very close to 0, a very poor result considering this
simulation does not contain any noise.

### Python 2

In this example the blue line is the original signal and the red dots depict
our measurements. When these are taken at 1.5 times the signal sampling rate
we get aliasing, with frequency  lower than the original.
When at 2.2 times the highest frequency of the signal we see some
additional features that did not appear on the original signal. In general it
is advisable to sample at leas 5 times per cycle, because information that
approaches the Nyquist frequency can still be poorly reconstructed, specially
in the presence of noise.

```{python}
## Related: getting close to the Nyquist

# subsample a high-sampling rate sine wave (pretend it's a continuous wave)
srate = 1000
t = np.arange(0,1,1/srate)
f = 10 # frequency of the sine wave Hz
d = np.sin(2*np.pi*f*t)

# Set the plots
fig, panels = plt.subplots(2, 2, sharex=True, sharey=True)
panels = panels.flatten()

# "Measurement" sampling rates
for idx, srate in enumerate([15, 22, 50, 200]):
    
    # plot 'continuous' sine wave
    panels[idx].plot(t,d)
    
    # plot sampled sine wave
    samples = np.arange(0,len(t),1000/srate)
    samples = list( map(int,samples) )
    panels[idx].set_title(f"Sampled at {srate/f:.01f} ({srate=})")
    panels[idx].plot(t[samples],d[samples],'r.-')
```

### Implications of aliasing in down-sampling


If you're going to down-sample your time series data, it's important to apply a
low pass filter so the Nyquist frequency corresponding to the sampling rate
after down-sampling. For example, if your original data were recorded at 2000
hertz and you want to down-sample to 500 hertz, then the new Nyquist frequency
is going to be 250 hertz: any features in the signal above 250 hertz will
become aliased in the down-sampled version. So therefore, in this particular
example, you would low pass filter the data at 250 hertz before down-sampling
to 500 hertz [for more detail, see the course on signal processing].

## Stationarity and non-stationarity

There are many descriptive statistics that can be used to describe time series
data. Descriptive statistics include the mean/average, which is the expected
value, the centre of the distribution. The mode or the median represent similar
concepts. The variance depicts the dispersion around the mean. Other
descriptors are the frequency, spectral shapes or the amplitude.

- Mean (average or expected value)
- Variance (dispersion around the mean)
- Kurtosis (shape of distribution)
- Heteroscedasticity (variance of deviances over time)
- Mode (most frequent value)
- Dominant frequency
- Spectral shape
- Phase stability
- Amplitude
- Covariance patterns

These descriptive statistics can be calculated for a large window including the
full length of the singnal, or over smaller windows containing just a subset of
the time series. What it actually matters is the placement and size/width of
the window. This question gets at the heart of the concept of a stationary
signal: stationary means that the characteristics of the signal are the same
everywhere you look in the signal. For example, the same average regardless the
placement of the window

A signal is stationary when its statistical characteristics do not
significantly change over time. Therefore, if its statistics change over time
this assumption is violated, and the signal is considered non-stationary.
Wether a signal is considered stationary or not depends on the descriptors.
For example, a signal can be amplitude stationary, but frequency non-
stationary, or viceversa. Furthermore, which window size do we take to
determine wether a signal is stationary or not? Because it may look stationary
at one scale, but non-stationary at a different one. Finally, it is difficult
to set a threshold to make this binary decision, specially on the case of noisy
signals. In practice different disciplines have devised different solutions to
address these questions.

## Effects of non-stationarities on power spectra

Non-stationarities are present in all kinds of signals (e.g., biology). In
fact, in many cases the non-stationarities are of primary interest and the
stationary features are considered uninteresting. For example, without any
non-stationarities, voices or music would just be a pure, monotonous tone.
However, if we apply the Fourier transform over the full length of the signal,
it will tell us very little about these non-stationarities.

### Python 1: amplitude non-stationarity

We create a normal sine wave with a frequency of 3 Hz, and multiply element-
wise by a time-varying amplitude. In one case it will go from 1 to 10 units,
or use the average amplitude value. Then we calculate their amplitude spectra.

```{python}
## amplitude non-stationarity

srate = 1000
t = np.arange(0,10,1/srate)
n = len(t)
f = 3 # frequency in Hz

# sine wave with time-increasing amplitude
ampl1 = np.linspace(1,10,n)
ampl2 = np.mean(ampl1)

# uncomment the next lines for an AM-radio-like signal
# y1 = 10*np.random.rand(10)
# fr = interpolate.interp1d(np.linspace(t[0],t[-1],10),y1,kind='cubic')
# ampl1 = np.abs(fr(t))


signal1 = np.multiply(ampl1 , np.sin(2*np.pi*f*t) )
signal2 = np.multiply(ampl2 , np.sin(2*np.pi*f*t) )


# obtain Fourier coefficients and Hz vector
signal1X = scipy.fftpack.fft(signal1)/n
signal2X = scipy.fftpack.fft(signal2)/n
hz = np.linspace(0,srate/2,int(np.floor(n/2)+1))

plt.plot(t,signal2,'r')
plt.plot(t,signal1,'b')
plt.title('Time domain signal')
plt.show()

plt.plot(hz,2*np.abs(signal2X[0:len(hz)]),'ro-')
plt.plot(hz,2*np.abs(signal1X[0:len(hz)]),'bs-')
plt.xlim([1,7])
plt.title('Frequency domain')
plt.show()
```

The red line corresponds to the stationary signal and the blue line corresponds
to the amplitude non-stationary one. The red spectrum shows a pure sine wave at
exactly 3 Hz. The blue signal has its peak on the same place, but has a lot of
non-zero energy at surrounding frequencies, from 1 to 5-6 Hz. This happens
because the non-stationarities in the signal require energy at neighboring
frequencies, in order to perfectly reconstruct the signal (in particular, in
the side lobes).

### Python 2: frequency non-stationarity (chirp)

This example is a frequency non-stationary signal containing a sine wave whose
frequency changes over time (chirp). `signal1` creates the chirp, and `ignal2`
is a stationary signals that uses the average of the chirp as the only
frequency.

```{python}
## Frequency nonstationarities

n = 10_000 # set explicitly

f  = [2, 10]
ff = np.linspace(f[0],np.mean(f),n)
signal1 = np.sin(2*np.pi*ff*t)
signal2 = np.sin(2*np.pi*np.mean(ff)*t)

# compute FFTs
signal1X = scipy.fftpack.fft(signal1)/n
signal2X = scipy.fftpack.fft(signal2)/n
hz = np.linspace(0,srate/2,int(np.floor(n/2)))

plt.plot(t,signal1)
plt.plot(t,signal2)
plt.title('Time domain')
plt.show()

plt.plot(hz,2*np.abs(signal1X[0:len(hz)]))
plt.plot(hz,2*np.abs(signal2X[0:len(hz)]))
plt.xlabel('Frequency (Hz)')
plt.title('Frequency domain')
plt.xlim([0,20])
plt.show()
```

The chirp (`signal1`) has an increasing frequency over time, start ing at 2 Hz
and speeding to 10 Hz, whereas the other (`signal2`) is just a pure sine wave.
When we look at the frequency domain plots the stationary signal looks exactly
as we would expect, with a sole peak with amplitude $1$ at 4Hz (mean of the
boundaries, 2 and 6). It is easy to guess how it will look like on the time
domain. However, the the chirped function looks like a rounded plateau rising
around 2 Hz and decreasing around 10 Hz. This shape could appear for many
signals, such as band-limited noise (a pure noise spectrum filtered to this
range).

Furthermore, even though both signals are amplitude stationary (amplitude does
not change), the amplitude spectrum of the chirped signal is never close to 1.
This is because of the non-stationarities, which cause the peak to widen,
making it more difficult to interpret.

### Python 3: different 

In this example the signal is frequency- and amplitude-stationary, but only
over specific windows, which have sharp transitions between them. The peaks
of the amplitude spectrum represent all the individual elements, with 4 peaks
for four components (1, 3, 6, 12 Hz). However, the amplitudes are not well
represented: for example, the amplitude at 3 Hz should be 10, but on the
spectrum it is just 2.5. This value kinda makes sense, because the 3 Hz signal
is 1/4 of the time series, and the amplitude is also 1/4 of the initial
specification. Once again it is difficult to tell how the time domain would
look like just by looking at the amplitude spectrum, for example, it could be
just the four sine components, with some random noise added on top.

```{python}
## sharp transitions

n = 10_000 # set explicitly

a = [10, 2, 5,  8]
f = [ 3, 1, 6, 12]

timecuts = np.round(np.linspace(0,n,len(a)+1)).astype(int)

signal = np.concatenate(
    [a[i]*np.sin(2*np.pi*f[i]*t[timecuts[i]:timecuts[i+1]]) for i in range(4)],
    axis=0
    )

signalX = scipy.fftpack.fft(signal)/n
hz = np.linspace(0,srate/2,int(np.floor(n/2)+1))

plt.plot(t,signal)
plt.title('Time domain')
plt.show()

plt.plot(hz,2*abs(signalX[0:len(hz)]))
plt.title('Frequency domain')
plt.xlim([0, 20])
plt.show()
```

### Python 4: phase reversal

In this example we see a phase reversal: we generate a pure 10 Hz signal where
both amplitude and frequency are fixed, but the phase of half of the signal is
reversed by multiplying by $-1$. On the time domain we see the signal looks
somewhat normal, but on the frequency domain there is something strange. The
Fourier coefficient for the signal frequency is exactly $0$. This is because
each half of the signal is the phase-opposite of the other, making them to
cancel out. In this case the non-stationarity stems from the change in phase,
which is absorbed by the side-lobes around the peak of the spectrum (9.5, 10.5
Hz), which decay as we go further from the original peak. [In the future we
will see some methods to recover information from non-stationary signals, in
this case you could use a windowing method, or Welch's method]

```{python}
## phase reversal

srate = 1000
time  = np.arange(0,2-2/srate,1/srate) # signal's time vector
signal = np.sin(2*np.pi*10*time)
n = len(time)

# Apply reversal to the 2nd half
signal[1000:] *= -1

plt.plot(time,signal)
plt.title('Time domain')
plt.show()

# power spectrum
signalAmp = (2*np.abs( scipy.fftpack.fft(signal)/n ))**2
hz = np.linspace(0,srate/2,int(np.floor(n/2)+1))

plt.plot(hz,signalAmp[0:len(hz)])
plt.xlim([0,20])
plt.title('Frequency domain')
plt.show()
```

### Python 5: sharp edges

In this example we have a sharp edge in the time domain, which cannot be
represented using sine waves. However, the Fourier theorem can approximate
the edge near-perfectly by using many, many sine waves at many frequencies.
Note that if we add a stationary signal atop of the edge we still will be able
to reconstruct the stationary component with the expected frequency and
amplitude.

```{python}
## edges and edge artifacts

n = len(t)
x = np.linspace(0,1,n)>.5

# uncommenting this line shows that nonstationarities 
# do not prevent stationary signals from being easily observed
x = x + .08*np.sin(2*np.pi*6*t)

plt.plot(t,x)
plt.title('Time domain')
plt.show()

# FFT
xX = scipy.fftpack.fft(x)/n
hz = np.linspace(0,srate/2,int(np.floor(n/2)+1))

plt.plot(hz,2*np.abs(xX[0:len(hz)]))
plt.xlim([0,20])
plt.title('Frequency domain')
plt.show()
```

### Python 6: spike in the frequency domain

For this example we will reverse our usual order, creating our time-domain
signal from the frequency domain. Here we just create a $0$ signal and add a
sole impulse/spike in the time domain. It corresponds to a simple sine wave
in the time domain, so it is interesting to think about a sine wave as a
ringing artifact from a sharp edge, or an impulse in the frequency domain.

```{python}
## spike in the frequency domain

# frequency spectrum with a spike
fspect = np.zeros(300)
fspect[10] = 1

# time-domain signal via iFFT
td_sig = np.real(scipy.fftpack.ifft(fspect)) * len(fspect)


# plot amplitude spectrum
plt.stem(fspect)
plt.title('Frequency domain')
plt.show()

# plot time domain signal
plt.plot(td_sig)
plt.title('Time domain')
plt.show()

```

## Solutions for non-stationary time series

```python
## create signal (chirp) used in the following examples

# simulation details and create chirp
fs     = 1000 # sampling rate
time   = np.arange(0,5,1/fs)
npnts  = len(time)
f      = [10,30] # frequencies in Hz
ff     = np.linspace(f[0],np.mean(f),npnts)
signal = np.sin(2*np.pi*ff*time)



plt.plot(time,signal)
plt.title('Time domain signal')
plt.show()

# compute power spectrum
sigpow = 2*np.abs(scipy.fftpack.fft(signal)/npnts)**2
hz     = np.linspace(0,fs/2,int(np.floor(npnts/2)+1))

plt.plot(hz,sigpow[0:len(hz)])
plt.xlim([0,80])
plt.title('Power spectrum')
plt.show()

```


```python
## short-time FFT

winlen   = 500  # window length
stepsize =  25  # step size for STFFT
numsteps = np.floor( (npnts-winlen)/stepsize )

hz = np.linspace(0,fs/2,int(np.floor(winlen/2)+1))


# initialize time-frequency matrix
tf = np.zeros( (len(hz),int(numsteps)) )

# Hann taper
hwin = .5*(1-np.cos(2*np.pi*np.linspace(0,winlen,winlen-1) / (winlen-1)))

# loop over time windows
for ti in range(0,int(numsteps)-1):
    
    # extract part of the signal
    tidx    = range(ti*stepsize+1,ti*stepsize+winlen)
    tapdata = signal[tidx]
    
    # FFT of these data
    x = scipy.fftpack.fft( np.multiply(hwin,tapdata) ) /winlen
    
    # and put in matrix
    tf[:,ti] = 2*np.abs(x[0:len(hz)])


plt.contourf(range(0,int(numsteps)),hz,tf,40)#,'linecolor','none')
plt.ylim([0,50])
plt.clim([0,.5])
plt.xlabel('Time steps')
plt.ylabel('Frequency (Hz)')
plt.title('Time-frequency power via short-time FFT')
plt.colorbar
plt.show()

```


```python
## Morlet wavelet convolution

# frequencies used in analysis
nfrex = 30
frex  = np.linspace(2,50,nfrex)
wtime = np.arange(-2,2,1/fs)
gausS = np.linspace(5,35,nfrex)

# convolution parameters
nConv = len(wtime) + npnts - 1
halfw = np.floor(len(wtime)/2)

# initialize time-frequency output matrix
tf = np.zeros((nfrex,npnts))

# FFT of signal
signalX = scipy.fftpack.fft(signal,nConv)

# loop over wavelet frequencies
for fi in range(0,nfrex):
    
    # create the wavelet
    s   = ( gausS[fi]/(2*np.pi*frex[fi]) )**2
    cmw = np.multiply( np.exp(1j*2*np.pi*frex[fi]*wtime) , np.exp( (-wtime**2)/s ) )
    
    # compute its Fourier spectrum and normalize
    cmwX = scipy.fftpack.fft(cmw,nConv)
    cmwX = cmwX/max(cmwX); # scale to 1
  
    # convolution result is inverse FFT of pointwise multiplication of spectra
    convres  = scipy.fftpack.ifft( np.multiply( signalX,cmwX ) )
    tf[fi,:] = 2*np.abs(convres[range(int(halfw+1),int(len(convres)-halfw+2))])

plt.contourf(time,frex,tf,40)
#set(gca,'ylim',[0 50],'xlim',[0 5],'clim',[0 1])
plt.xlabel('Time (s)')
plt.ylabel('Frequency (Hz)')
plt.title('Time-frequency power via complex Morlet wavelet convolution')
plt.show()
```
## Windowing and Welch's method

```python
# create signal
srate = 1000
npnts = 2000 # actually, this times 2!
time  = np.arange(0,npnts*2)/srate
freq  = 10 # Hz

# create signal (each part separately)
sigP1  = np.sin(2*np.pi*freq*time[0:npnts])
sigP2  = np.sin(2*np.pi*freq*time[0:npnts] + np.pi)
signal = np.concatenate((sigP1,sigP2),axis=0)

# compute its amplitude spectrum
hz = np.linspace(0,srate/2,num=int(np.floor(len(time)/2)+1))
ampspect = np.abs(scipy.fftpack.fft(signal)/len(time))
ampspect = 2*ampspect[0:len(hz)]


# plot the time-domain signal
plt.plot(time,signal)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Time domain')
plt.show()

# plot the frequency domain signal
plt.stem(hz,ampspect)
plt.xlim(0,freq*2)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('Frequency domain (FFT)')
plt.show()
```


```python
## Now for Welch's method

# parameters
winlen = 1000 # window length in points (not ms!)
nbins  = np.floor(len(time)/winlen)

# vector of frequencies for the small windows
hzL = np.linspace(0,srate/2,int(np.floor(winlen/2)+1))

# initialize time-frequency matrix
welchspect = np.zeros(len(hzL))

# Hann taper
hwin = .5*(1-np.cos(2*np.pi*(np.arange(0,winlen)) / (winlen-1)))

# loop over time windows
for ti in range(int(nbins)):
    
    # extract part of the signal
    tidx    = range( (ti-1)*winlen+1 , ti*winlen+1 )
    tmpdata = signal[tidx]
    
    # FFT of these data (does the taper help?)
    x = scipy.fftpack.fft(hwin*tmpdata)/winlen
    
    # and put in matrix
    welchspect = welchspect + 2*np.abs(x[0:len(hzL)])

# divide by nbins to complete average
welchspect = welchspect/nbins


# and plot
plt.stem(hzL,welchspect)
plt.xlim(0,freq*2)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('Frequency domain (Welch''s method)')
plt.show()
```

## Instantaneous frequency

```python

# simulation details
srate = 1000
time  = np.arange(0,4,1/srate)
pnts  = len(time)

# frequencies for Fourier transform
hz = np.linspace(0,srate/2,int(np.floor(pnts/2)-1))


# frequency range for linear chirp
f  = [7,25]

# generate chirp signal
ff = np.linspace(f[0],np.mean(f),pnts)
signal = np.sin(2*np.pi*ff*time)

# compute instantaneous frequency
angels = np.angle(scipy.signal.hilbert(signal))
instfreq = np.diff(scipy.unwrap(angels)) / (2*np.pi/srate)

# time-domain signal
plt.plot(time,signal)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Time domain')
plt.show()

# frequency domain ("static" power spectrum)
amp = 2*np.abs(scipy.fftpack.fft(signal)/pnts)
plt.plot(hz,amp[:len(hz)])
plt.title('Frequency domain')
plt.xlim(0,np.minimum(srate/2,f[1]*3))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.show()

# now show instantaneous frequency
plt.plot(time[:-1],instfreq)
plt.ylim(f[0]*.8,f[1]*1.2)
plt.xlabel('Time (s)')
plt.ylabel('Frequency (Hz)')
plt.title('Instantaneous frequency')
plt.show()

```
