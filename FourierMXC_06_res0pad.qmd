# Frequency resolution and zero padding

```{python}
import numpy as np
import math
import matplotlib.pyplot as plt
import random
import timeit
import scipy.fftpack
from mpl_toolkits.mplot3d import Axes3D
```

## Sampling theorem

### The importance of the sampling rate

*I'm going to talk about frequency resolution, which refers to the spacing
between subsequent frequencies*. However, before that, it is necessary to talk
about sampling, and the limits of using discrete digital measurements to
represent continuous analog signals.

We live in an analog universe, which contains continuous signals, *for example,
the vibrations of my vocal cords produce sounds with smooth fluctuations in
pitch and frequency. No matter how finely my microphone samples my voice, it
could always be sampled at smaller intervals and still record my voice*
(up to the Planck scale).

Voices and many other signals in the universe are continuous and analog,
whereas the signals we record are not continues, but rather discretely sampled measurements. Analog signals could be imagined as a continuius infinitely
detailed line, whereas the discrete signals would be points over that line
with some spacing. When the sampling is high enough the sampled signal will
look very similar to the continuous original, with this similary degrading if
the sampling frequency is not high enough to to reflect the details of the
original. As the measurement only can be taken once, is vital to have an
appropriate sampling rate. This has several implications.

1. Time points are discrete and is not possible to know what happened between
them. In many cases it's reasonable to assume smooth transitions between points.
This assumption is more reasonable for denser samplings, but if the sampling
rate is too low relative to the fluctuations in the actual signal, then you
could be missing features of the data, and if this information is not captured
during measurement, it is lost.

2. [no second point]

Similarly, frequencies are discrete and you don't actually know what happens
between them, reason why it is better to use stem plots or bar plots to show
power spectra. Using line plots, imply there are amplitude values for any
arbitrary frequency, which is not true (it may was not be possible to measure
this frequency from the signal). However, for practical reasons, line plots
still are used to show spectra from multiple sources at the same time.

### The Nyquist frecuency

It is not possible to measure any signals faster than the Nyquist frequency,
which is half of the data sampling rate. If the continuoaus analog signal has frecuencies larger (faster) than the Nyquist frequency, are these are aliased
into lower frequencies, becoming artifacts in the data [see later]. Thus, it is
advisable to sample with a higher frequency than twice the highest frequency
you expect to find in the data. *This will increase the signal to noise and
give you higher quality estimates of the dynamics at higher frequencies that
approach the Nyquist frequency*.

### The frequency resolution

The discrete temporal sampling is directly linked to the frequency resolution
(also called spectral resolution). This concept is the distance between two
successive frequency points, and as in the case of the temporal sampling,
any spectral energy that may appear between them will not be captured.
[example based on an illustration].

The frequency resolution of a signal is the sampling rate divided by the number
of points in the signal. *So if you sample at 1000 hertz, or one kilohertz, and
you measure the signal for two thousand points (2 seconds), then the frequency
resolution half an hertz.

Following this formula, the frequency resolution depends on the sampling rate
and the number of data points. Then, we can just increase the number of points
to increase the frequency resolution [see chapter on 0 padding].

In fact this also is reflected by the code for the loop-based discrete Fourier
transform [code], where the frequency resolution is determined entirely by the
number of points in the signal. Showing this is one of the reasons for teaching
the slow version instead of directly using a fast FFT implementation.

The number of the template sine waves that are created depends on the number of
points. [...] When you divide the looping index by the Nyquist frequency, then
that gives you the total range of frequencies.

### Python

We are going to pretend we have a signal with a sampling rate of 1000 hertz
(1 kilohertz) with of 1 second (1000 time points). The frequency resolution is
just the sampling rate divided by the number of points (analytic frequency
resolution). There is also the concept of the empirical frequency resolution,
the spacing between all of the different frequencies. In this case, the
distance between them is linear, because we're linearly spacing numbers between
Zero and Nyquist to generate the vector of frequencies in Hertz, and then
average of all of those.

```{python}
# create the signal
srate  = 1000
pnts   = 1000
signal = np.random.randn(pnts)


# The loop of the Fourier transform (although we're not computing it)
#for fi in range(0,pnts):
    #csw = np.exp( -1i*2*np.pi*fi*fourTime )
    #fCoefs[fi] = np.sum( np.multiply(signal,csw) ) / pnts


# compute frequencies vector
hz = np.linspace(0,srate/2,int(np.floor(pnts/2)+1))

# compute frequency resolution
analytic_freqres =srate/pnts
empiric_freqres = np.mean(np.diff(hz))

# print result in command window
print('Frequency resolution is', analytic_freqres, 'Hz')

```


```{python}
# parameters (try adjusting the srate!)
srate  = 10
time   = np.arange(0,2,1/srate)

# create signal
signal = np.zeros(len(time))
signal[0:int(np.round(len(time)*.1))] = 1

# spectrum and frequencies vector
signalX = scipy.fftpack.fft(signal)
hz = np.linspace(0,srate,len(time)) # plotting trick... frequencies really only go up to Nyquist

# plot
plt.plot(time,signal,'s-')
plt.xlabel('Time (sec.)')
plt.ylabel('Amplitude')
plt.title('Time domain')
plt.show()

plt.plot(hz,2*abs(signalX),'s-')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.title('Frequency domain')
plt.show()
```
Here we create a time domain signal that goes from zero to two seconds with a
sampling rate of 10 hertz, and set the first 10% of the data equal to one [...].
The frecuency resolution is $0.5$ and the Nyquist frequency is at 5Hz.

If we change the signal length to 20 seconds, the frequency resolution becomes
$0.05$. The plot on the time domain is just more detailed, but in the time
omain it just has many more points.

With a length of length of 2 sconds and a sampling rate of 100 Hz, the
frequency resolution goes back to $0.5$, and the Nyquist frequency is at 50 Hz.

The generation of the hertz vector is a bit hacky, which reaches up the total
sampling rate instead up to the Nyquist frequency. That means all the
frequencies past the Nyquist are incorrect, as they frequency should decrease
to represent the negative frequencies. It is just a plottong trick.

### Summary

We can only understand a system if we can measure it. However, on a computer
any signal is digitized and discrete. Any process faster than the sampling
cannot be analyzed: signal frequencies over the Nyquist frequency will be
aliased/lost, and we can only assume there are smooth transitions between
successive frequency points. The sampling frequency in the time domain is
connected to the sampling frequency resolution and the signal length.

## Time-domain zero padding

Frequency resolution depends on the signal sampling and its length (number of
points). There may be cases where we need to increase the frequency resolution,
but is not possible to acquire more data. The [a?] solution a procedure called
zero padding, which is adding a bunch of zeroes at the end of the time series.
Note the number of time points is increased, but not the information content.

### Python (manual)

In this case our signal will be just a Hann taper, which looks like half a
cosine. Then apply the FFT, and extract the amplitude (unnormalized). The
un-padded signal looks like a very rapidly decaying exponential function.
hen the the signal padded with 40 zeroes is taken to the frequency domain, it
seems to interpolate between the frequencies of the un-padded signal. In fact,
that's really what's happening: this amplitude spectrum is basically a sinc-
interpolated version of thies original (un-padded) amplitude spectrum. It is
also interesting that the frequencies are between the original points, we don't
get extra frequencies at the beginning or the end.

```{python}
# create the signal
signals = [np.hanning(40)]
signals.append(np.concatenate(( signals[0], np.zeros(len(signals[0]))), axis=0))

fig, panels = plt.subplots(2, 2, sharex="row", sharey="row")
panels[0, 0].set_ylabel('Amplitude (time)')
panels[1, 0].set_ylabel('Amplitude (freq.)')

for col_idx, signal in enumerate(signals):
    # time the fast Fourier transform
    signalX = scipy.fftpack.fft(signal)

    # extract amplitude
    ampl = np.abs(signalX)#2 * /len(signal)

    # normalized frequency units
    frequnits = np.linspace(0, 1, len(signal))

    # and plot
    panels[0, col_idx].plot(signal, 'ks-')
    panels[1, col_idx].stem(frequnits, ampl, "k")

    # SET BOUNDS AND LABELS
    panels[1, col_idx].set_xlim(-.01,.3)
    panels[1, col_idx].set_xlabel('Frequency (a.u.)')

fig.tight_layout()
```

### Python (better way)

In practice the FFT function allows to set the number of frequency bins (`n`).
If this number, is smaller than the length of the signal the function only will
take the first `n` points, whereas if it is larger, the signal will get padded
with zeroes. Here we just take a small signal and we pad it with different
amounts of zeroes to add (0, 10, 100).

```{python}
## zero-padding in fft function

# create the signal
signal = [ 4, 6, -1, 0, 5, -4 ]

# number of zeros to add after signal
for pad in [ 0, 10, 100 ]:
    
    # total length of signal
    zeropadN = len(signal) + pad
    
    # FFT and amplitude
    sigampl   = np.abs( scipy.fftpack.fft(signal, n=zeropadN) )
    
    # one of the two normalization steps
    sigampl = sigampl / 1
    
    frequnits = np.linspace(0,1,zeropadN+1)
    
    # and plot
    plt.plot(frequnits[:-1],sigampl,'s-',label='%g-point FFT' %zeropadN)


# add some plot extras
plt.legend()
plt.xlabel('Frequency (.5 = Nyquist)')
plt.ylabel('Amplitude (a.u.)')
plt.show()
```

As the padding increases the amplitude spectrum gets smoother and smoother, as
a sinc-interpolated version of the original power spectrum.

### effects of zero padding on normalization

We know we have to multiply the positive coefficients by $2$, and divide by the
number of pooints. However, that number should be with, or without the padding?. 
If we use the padded length, the amplitude seems to drop as more zeroes are
added, whereas the correct normalization needs to be based on the length of
the original signal.

## Frequency-domain zero padding

Zero padding in the frequency domain will increase the temporal resolution when
the data is transformed back to the time domain. The result is an uplsampled
sinc-interpolated version of the original signal.

### Python

If we take the signal from the previous lesson and apply zero-padding in the
frequency domain. This is done using the `n` argument of the `ifft` function,
which expresses the length of the output array. If `n` is larger than the
length of the input signa, said signal will be zero-padded before being
transformed from the frequency- to the time-domain. To accomodate for this,
it is necessary to multiply by `new_length` to account for the impact of padding
on the amplitude, as well as creating a time vector with an adequate number of
elements. In this case ranges from 0 to one (normalized time units).

#### Example 1

```{python}
# create the signal
signal = [ 4, 6, -1, 0, 5, -4 ]

# fft
signalX = scipy.fftpack.fft(signal)
    
# number of zeros to add after spectrum
for pad in [ 0, 10, 100 ]:
    
    # spectral zero-padding
    new_length = len(signal) + pad
    
    # reconstruction via ifft
    reconSig = scipy.fftpack.ifft(signalX, n=new_length) * new_length
    normtime = np.linspace(0,1,len(reconSig))
    
    # and plot
    plt.plot(normtime,np.real(reconSig),'s-',label=f"{new_length}-point FFT")

# add some plot extras
plt.legend()
plt.xlabel('Time (norm.)')
plt.show()
```

In blue we have the near-original signal (we are not applying all the
appropriate normalizations). In orange and green we have the 10-padded signal,
and the 100-padded signal, each smoother than the last. The latter is excessive,
as it diverges from the original past 0.7, with the original gong down, whereas
the padded results go up again. This is not all that surprising: We're taking a
six-point signal and interpolating up by a full order of magnitude here.

#### Example 2

For a more extreme example, we are going to create a thresholded signal
$\sin (2 · \pi · f · t)$ that is $1$ if $f > 0.3$ and $0$ otherwise. The result
has non-stationarities, and a lot of very sharp edges, which has profound
implications on the interpretability of the Fourier transform [see next
section]. Now it is useful to illustrate the impact of sinc interpolation via
zero padding in the frequency domain.

In this case the signal will be lengthened by $1$ (same signal), $2$ and $5$
(two times and 5 times longer). For each loop we apply the `ifft`, which applies
the zero padding, and plot it in the time domain, and the frequency domain
(after transforming).

```{python}
## Another example

# create the signal
srate  = 1000
x      = np.array(range(0,256))/srate
signal = np.sin(2*np.pi*20*x)>.3

# setup axis
fig,ax = plt.subplots(2,1)

for color, pad_factor in {"b": 5, "r": 2, "k": 1}.items():
    
    # fft
    signalX = scipy.fftpack.fft(signal)
    
    # spectral zero-padding
    new_length = int(2**np.ceil(np.emath.logn(n=2, x=len(signal) * pad_factor)))
    
    # reconstruction via ifft
    reconSig = scipy.fftpack.ifft(signalX, new_length) * new_length
    normtime = np.linspace(x[0], x[-1], len(reconSig)) # new time vector
    srateNew = 1/np.mean(np.diff(normtime)) # new sampling rate
    
    # power spectrum
    ampl = np.abs(scipy.fftpack.fft( np.real(reconSig) ))
    hz   = np.linspace(0,srateNew/2,int(np.floor(len(reconSig)/2+1)))
    
    ax[0].plot(normtime, np.real(reconSig), label=f"{pad_factor=}", color=color)
    
    # plot amplitude spectrum
    ax[1].plot(hz,ampl[0:len(hz)], label=f"{pad_factor=}", color=color)


# add some plot extras
#ax[0].set_title('Time domain')
ax[0].set_xlim(left=0, right=.055) # optional zooming in
ax[0].set_xlabel('Time (sec.)')

#ax[1].set_title('Frequency domain')
#ax[1].set_ylabel('Amplitude (non-normalized)')
ax[1].set_xlim(left=-12, right=1200)
ax[0].set_xlim(left=0, right=.07) # optional zooming in
ax[1].set_xlabel('Frequency (Hz)')

fig.tight_layout()
```
In blue we have the original (256 points), and red and blue we have the
interpolated signals (512, 2048 points). The interpolated signals departs more
and more, artifacing with the increase of the zero-padding factor. These
artifacts stem from the sharp cuts of our thresholded signal.

Interestigly, both padded signals are similar when they are far away from the
edges (still an artifact), with more "ringing" closer to the edges. This topic
will be adressed on the next section [non-stationarities, interpretability of
the Fourier transform].


## Sampling rate vs. signal length

In this video, I'd like to clarify two distinct but related points that people often find confusing,

and that is the difference between temporal resolution and frequency resolution, and how those two are

related to the sampling rate versus the signal length.

So the sampling rate is just the number of sample points per second or per unit time that you acquire

from the measurement device. The sampling rate defines entirely the temporal resolution.

So the temporal resolution is the sampling rate regardless of the amount of time.

Now, that part is really sensible.

It gets trickier in the frequency domain because the frequency of resolution is not determined solely

by the data sampling rate the way that the temporal resolution is.

Instead, the frequency resolution is defined by a combination of the sampling rate and -- crucially --

the number of time points.

Now, you've already seen this in several videos before.

But I want to clarify some potentially confusing points in this video.

What makes this confusing in the frequency domain is that the length of the signal has nothing to do

with the data sampling rate.

So you can sample a lot or a little.

And that really is independent of the data sampling rate.

And it's the length of the signal that determines the frequency resolution, given a fixed sampling rate.

And that comes right out of the Fourier transform because the number of sine waves in the Fourier transform

corresponds exactly to the number of time points in the original signal.

I'm going to show a few pictures and then I'll make this distinction even more clear in Matlab.

So imagine you have data with a fixed sampling rate. So the data were already collected, someone gave

you the data, they measured it and the measurement is done.

You are doing offline spectral analyses.

So that means that the Nyquist frequency is immutable, you cannot change the Nyquist frequency because

the sampling rate is already fixed. So you can change the number of data points and that alone will

affect the frequency resolution.

So if you have relatively few data points, zero is always the lower limit.

Nyquist is fixed.

That's always going to be the upper limit.

So for a small number of data points, the frequency resolution might look something like this.

It's perhaps a little bit sparse.

If you do another FFT with more data points, the frequency resolution will increase because the Nyquist

frequency is fixed and the zero hertz is fixed.

That's always the floor.

And if you have really super-duper a lot of data points (this is a technical term here ;) ) then of course

the frequency resolution will increase even further.

Now, the data sampling rate doesn't change, so the temporal resolution is unchanged in any of these

cases.

It's only the frequency resolution that's changing.

Now, of course, that is not to say that the frequency resolution has nothing to do with the sampling

rate.

Because you could have a small number of data points.

That would give you this resolution. Or you can have exactly the same number of data points with a lower

sampling rate, and that would give you a higher frequency resolution.

But what we're doing here is shifting the Nyquist frequency compared to this case, which is different

from what I'm doing in these cases.

So in practical data analysis and offline data analysis, this is generally a more realistic scenario

because the sampling rate is already fixed and what you can play around with, what you can change, is

the number of time points, either the number of real time points or artificially increasing the number

of time points by zero padding.

All right.

Now let's switch to Matlab.

So what I'm going to do here is create three different signals that have two different sampling

rates and two different durations of time.

So it's going to have 100 hertz or 100 hertz or 1000 hertz sampling rate.

And the signal will be, for 100 hertz,

it will be either one second long or it will be 10 seconds long.

And the 1000 hertz sampling rate is going to be one second long.

So then we can compare that to this time series,

which is also going to be one second long, but with a sampling rate of 100 hertz.

So we're intermixing different sampling rates and time durations.

And in fact, I believe the time duration is really technically longer than this.

Yeah, so we start the time vector at minus one and then go up to whatever I have here.

So in fact, this is two seconds and 11 seconds, and two seconds, but that part doesn't really matter.

What does matter is what we do in this simulation.

So define the sampling rate, define the total duration of time, which is then also encoding the number

of time points. Generate a signal.

The signal is something called a Morlet wavelet, which is important for signal processing and time

frequency analysis.

It's basically just a cosine multiplied by a Gaussian.

Then I take its Fourier spectrum.

In this case, I'm normalising it to its maximum amplitude, and that's because they don't really care

about the units here, I just want to be able to compare the time domain and the frequency domain responses

of these three signals with these three parameters.

OK, and then I do some plotting.

So here we go.

Here we can see what this looks like.

Now, the question is, which of these three signals has the highest temporal resolution and which has

the highest spectral resolution?

Now, in the time domain, the answer to that question is pretty trivial.

The signal with the highest temporal resolution is the signal that has higher sampling rate.

That's really the definition of the sampling rate: the temporal resolution of the digitized signal.

So you can zoom in here and you see that the magenta stars and the black dots, these have

the same number of time points here... or sorry, the time points overlap here

and that's because they have the same sampling rate.

Now, the magenta stars will go on longer because that goes out to 11 seconds.

I'm not even plotting that here.

I'm just putting the first three seconds.

And then it's trivially obvious that the simulated signal with a higher sampling rate in the time domain

has more points in it.

So nothing really terribly interesting here. But it gets a little more confusing when we get into the

frequency domain.

So first of all, we can look in the frequency domain and see where do these signals go up to.

So these two signals, the black dot and the magenta star, those spectral

plots go up to 50 hertz because that is the Nyquist frequency of these two.

So they're both sampled at 100 hertz.

So they have they stop at 50 hertz.

I stop the plotting at 50 hertz.

So that is sensible, but it is different from this time domain signal, where the magenta star signal

went all the way up to 11 Hz, so much longer in the time domain. And the frequency domain, they are the

same.

Now, this signal, the blue dots, that goes up to 500 hertz because that's the Nyquist frequency of

this signal.

All right.

But the key question, the important question that we want to answer here, is which one has the highest

frequency resolution?

And you can see now the winner is this magenta star signal.

And that's not because it has the highest sampling rate.

It's because it goes on the longest -- it has the most number of time points.

And that's why it has the highest frequency resolution.

So I encourage you to spend some time and play around with these plots, play around with the simulation.

You can try changing the sampling rates and the duration of the signals and so on.

In this video, I showed you the distinction between temporal resolution and spectral resolution: temporal

resolution is determined entirely by the data sampling rate, by the measurement sampling rate, while

the frequency resolution is determined by the number of time points given a fixed sampling rate.

Now, these concepts are, of course, highly related to each other, but it's also important to see

how they provide unique contributions to the results of the Fourier transform.

```{python}
## difference between sampling rate and number of time points for Fourier frequencies

# temporal parameters
srates  = [100, 100, 1000]
timedur = [  1,  10,    1]
freq    = 5 # in Hz, for the signal


# setup plotting
fig,ax = plt.subplots(2,1)
colors  = 'kmb'
symbols = 'op.'
legendText = [0]*len(srates)


for parami in range(len(srates)):
    
    # define sampling rate in this round
    srate = srates[parami] # in Hz
    
    # define time
    time = np.arange(-1,timedur[parami],1/srate)
    
    # create signal (Morlet wavelet)
    signal = np.multiply( np.cos(2*np.pi*freq*time) , np.exp( (-time**2) / .05 ) )
    
    # compute FFT and normalize
    signalX = scipy.fftpack.fft(signal)
    signalX = signalX/np.max(signalX)
    
    # define vector of frequencies in Hz
    hz = np.linspace(0,srate/2,int(np.floor(len(signal)/2)+1))
    
    # plot time-domain signal
    ax[0].plot(time,signal,color=colors[parami],marker=symbols[parami])
    
    # plot frequency-domain signal
    ax[1].plot(hz,np.abs(signalX[0:len(hz)]),color=colors[parami],marker=symbols[parami])
    
    # legend text
    legendText[parami] = f'srate={srates[parami]}, N={timedur[parami]+1} s'


ax[0].set_xlim([-1,1])
ax[0].set_xlabel('Time (s)')
ax[0].set_ylabel('Amplitude')
ax[0].set_title('Time domain')
ax[0].legend(legendText)

ax[1].set_xlabel('Frequency (Hz)')
ax[1].set_ylabel('Amplitude')
ax[1].set_title('Frequency domain')
ax[1].legend(legendText)

fig.tight_layout()
fig.align_ylabels()
```
