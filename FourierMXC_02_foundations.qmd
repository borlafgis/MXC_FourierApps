# 2. Foundations of the Fourier transform

```{python}
import numpy as np
import math
import matplotlib.pyplot as plt
import pylab as pl
# from IPython import display
import time as ttime
import random
from mpl_toolkits.mplot3d import Axes3D
```


---
# VIDEO: Complex numbers
---



```{python}
# writing the complex number as real + imaginary
z = 4 + 1j*3
print(z)

# using the function complex
z = complex(4,3)    # this way
z = complex('4+3j') # or this way
print(z)

```


```{python}
# plot the complex number on the complex plane

plt.plot(np.real(z),np.imag(z),'ro')

# some plotting touch-ups
plt.axis('square')
plt.axis([-5, 5, -5, 5])
plt.grid(True)
plt.xlabel('Real axis'), plt.ylabel('Imaginary axis')
plt.show()
```


```{python}
# compute the magnitude of the complex number using Pythagorean theorem
mag = np.sqrt( np.real(z)**2 + np.imag(z)**2 )

# or using abs
mag = np.abs(z)

print( 'The magnitude is',mag )
```


```{python}
# compute the angle of the complex number using Pythagorean theorem
phs = math.atan( np.imag(z) / np.real(z) )

# or using abs
phs = np.angle(z)

print( 'The angle is',phs )
```


---
# VIDEO: Euler's formula
---



```{python}
x = np.linspace(-3,3,num=50)

plt.plot(x,np.exp(x),label='$y=e^x$')

# some plotting touch-ups
plt.axis([min(x),max(x),0,np.exp(x[-1])])
plt.grid(True)
plt.legend()
plt.xlabel('x')
plt.show()

```


```{python}
# [cos(k),sin(k)] is on the unit circle for any real k

# define k (any real number)
k = 2/np.pi

# Euler's notation
euler = np.exp(1j*k)

# plot dot
plt.plot(np.cos(k),np.sin(k),'ro')

# draw unit circle for reference
x = np.linspace(-np.pi,np.pi,num=100)
plt.plot(np.cos(x),np.sin(x))

# some plotting touch-ups
plt.axis('square')
plt.grid(True)
plt.xlabel('Real axis'), plt.ylabel('Imaginary axis')
plt.show()
```


```{python}
# Euler's formula with arbitrary vector magnitude

m = 4; # magnitude
k = np.pi/3; # phase
compnum = m*np.exp( 1j*k );

# extract magnitude and angle
mag = np.abs(compnum);
phs = np.angle(compnum);

plt.polar([phs,phs],[0,mag])
plt.show()
```



---
# VIDEO: sine waves and complex sine waves
---




```{python}
# simulation parameters
srate = 500; # sampling rate in Hz
time  = np.arange(0.,2.,1./srate) # time in seconds

# sine wave param.eters
freq = 3;    # frequency in Hz
ampl = 2;    # amplitude in a.u.
phas = np.pi/3; # phase in radians

# generate the sine wave
sinewave = ampl * np.sin( 2*np.pi * freq * time + phas )

plt.plot(time,sinewave,'k')
plt.xlabel('Time (sec.)')
plt.ylabel('Amplitude (a.u.)')
plt.show()
```


```{python}
# sine and cosine are the same but for a phase shift

# generate the sine wave
sinewave = ampl * np.sin( 2*np.pi * freq * time + phas )
coswave  = ampl * np.cos( 2*np.pi * freq * time + phas )

plt.plot(time,sinewave,'k',label='sine')
plt.plot(time,coswave,'r',label='cosine')
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude')
plt.title('A sine and cosine with the same parameters.')
plt.show()
```


```{python}
# complex sine waves

# general simulation parameters
srate = 500; # sampling rate in Hz
time  = np.arange(0.,2.,1./srate) # time in seconds

# sine wave parameters
freq = 5;    # frequency in Hz
ampl = 2;    # amplitude in a.u.
phas = np.pi/3; # phase in radians

# generate the sine wave
csw = ampl * np.exp( 1j* (2*np.pi * freq * time + phas) );

# plot the results
plt.plot(time,np.real(csw),label='real')
plt.plot(time,np.imag(csw),label='imag')
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude')
plt.title('Complex sine wave projections')
plt.legend()
plt.show()

```


```{python}
# now show in 3D
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
ax.plot(time,np.real(csw),np.imag(csw))
ax.set_xlabel('Time (s)'), ax.set_ylabel('Real part'), ax.set_zlabel('Imag part')
ax.set_title('Complex sine wave in all its 3D glory')
plt.show()
```


---
# VIDEO: The dot product
---



```{python}
# two vectors
v1 = [ 1, 2, 3 ];
v2 = [ 3, 2, 1 ];

# compute the dot product
dp = sum( np.multiply(v1,v2) )

print('The dot product is',dp)
```


```{python}
# dot products of sine waves

# general simulation parameters
srate = 500; # sampling rate in Hz
time  = np.arange(0.,2.,1./srate) # time in seconds

# sine wave parameters
freq1 = 5;    # frequency in Hz
freq2 = 5;    # frequency in Hz

ampl1 = 2;    # amplitude in a.u.
ampl2 = 2;    # amplitude in a.u.

phas1 = np.pi/2; # phase in radians
phas2 = np.pi/2; # phase in radians

# generate the sine wave
sinewave1 = ampl1 * np.sin( 2*np.pi * freq1 * time + phas1 );
sinewave2 = ampl2 * np.sin( 2*np.pi * freq2 * time + phas2 );

# compute dot product
dp = np.dot(sinewave1,sinewave2);

# print result
print('dp =',dp)
```


```{python}
# with a signal

# phase of signal
theta = 0*np.pi/4;


# simulation parameters
srate = 1000;
time  = np.arange(-1.,1.,1./srate)

# signal
sinew  = np.sin(2*np.pi*5*time + theta)
gauss  = np.exp( (-time**2) / .1);
signal = np.multiply(sinew,gauss)

# sine wave frequencies
sinefrex = np.arange(2.,10.,.5);

# plot signal
plt.plot(time,signal)
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude (a.u.)')
plt.title('Signal')
plt.show()



# initialize dot products vector
dps = np.zeros(len(sinefrex));

# loop over sine waves
for fi in range(len(dps)):

    # create sine wave
    sinew = np.sin( 2*np.pi*sinefrex[fi]*time)

    # compute dot product
    dps[fi] = np.dot( sinew,signal ) / len(time)


# and plot
plt.stem(sinefrex,dps)
plt.xlabel('Sine wave frequency (Hz)'), plt.ylabel('Dot product')
plt.title('Dot products with sine waves')
plt.show()
```


---
# VIDEO: The complex dot product
---



```{python}
# phase of signal
theta = 0*np.pi/4;


# simulation parameters
srate = 1000;
time  = np.arange(-1.,1.,1./srate)

# signal
sinew  = np.sin(2*np.pi*5*time + theta)
gauss  = np.exp( (-time**2) / .1);
signal = np.multiply(sinew,gauss)


# sine wave frequencies
sinefrex = np.arange(2.,10.,.5);

# plot signal
plt.plot(time,signal)
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude (a.u.)')
plt.title('Signal')
plt.show()



# initialize dot products vector
dps = np.zeros(len(sinefrex),dtype=complex)

# loop over sine waves
for fi in range(len(dps)):

    # create sine wave
    sinew = np.exp( 1j*2*np.pi*sinefrex[fi]*time )

    # compute dot product
    dps[fi] = np.abs( np.vdot( sinew,signal ) / len(time) )


# and plot
plt.stem(sinefrex,dps)
plt.xlabel('Sine wave frequency (Hz)'), plt.ylabel('Dot product')
plt.title('Dot products with sine waves')
plt.show()
```


```{python}
# in more detail...

# phase of signal
theta = 1*np.pi/4;

# signal
sinew  = np.sin(2*np.pi*5*time + theta)
gauss  = np.exp( (-time**2) / .1)
signal = np.multiply(sinew,gauss)

# create sine and cosine waves
sinew = np.sin( 2*np.pi*5*time )
cosnw = np.cos( 2*np.pi*5*time )

# compute dot products
dps = np.dot( sinew,signal ) / len(time)
dpc = np.dot( cosnw,signal ) / len(time)

# combine sine and cosine into complex dot product
dp_complex = complex(dpc,dps) # cos/sin were swapped in the video
mag = np.abs(dp_complex)
phs = np.angle(dp_complex)

# and plot
plt.plot( dpc , dps ,'ro')
plt.xlabel('Cosine axis')
plt.ylabel('Sine axis')
plt.axis('square')
plt.grid(True)
plt.axis([-.2,.2,-.2,.2])
plt.show()

# draw a line using polar notation
plt.polar([phs,phs],[0,mag])
plt.show()
```


```{python}

# create complex sine wave
csw = np.exp( 1j*2*np.pi*5*time )
rsw = np.sin(    2*np.pi*5*time )

# specify range of phase offsets for signal
phases = np.arange(0, 2 * np.pi, np.pi/4) # np.linspace(0, 7 * np.pi/2, num=8)

# Prepare the colors
cmap = plt.get_cmap('hsv')
colors = cmap(np.linspace(0, 1, len(phases) + 1))

# create a figure as a subplot mosaic
fig = plt.figure(figsize=(5, 5), layout='constrained')
axes = fig.subplot_mosaic([['time', 'time'], ['complex', 'normal']])
axes['time'].set_title('Signal and sine wave over time')

# Plot rsw a single time
axes['time'].plot(time, rsw, color='k', lw=2.5, zorder=0)
axes['time'].set_xlim(-.75, .75)

for plot_id in ('complex', 'normal'):
    axes[plot_id].set_title(f"{plot_id.capitalize()} dot product")
    axes[plot_id].set_aspect('equal')
    axes[plot_id].set_ylim(-.175, .175)
    axes[plot_id].set_ylabel('Imaginary')
    axes[plot_id].set_xlim(-.175, .175)
    axes[plot_id].set_xlabel('Real')
    axes[plot_id].axhline(0, color='k', zorder=0)
    axes[plot_id].axvline(0, color='k', zorder=0)

for phi in range(0,len(phases)):

    # create signal
    sinew  = np.sin(2*np.pi*5*time + phases[phi])
    gauss  = np.exp( (-time**2) / .1)
    signal = np.multiply(sinew, gauss)

    # compute complex dot product
    cdp = np.sum( np.multiply(signal,csw) ) / len(time)

    # compute real-valued dot product
    rdp = sum( np.multiply(signal,rsw) ) / len(time)

    # plot signal and real part of sine wave
    axes['time'].plot(time, signal, color=colors[phi])

    # plot complex dot product
    axes['complex'].scatter(np.real(cdp), np.imag(cdp), color=colors[phi])
    axes['complex'].plot([0, np.real(cdp)], [0, np.imag(cdp)], color=colors[phi])

    # plot normal dot producr
    axes['normal'].scatter(rdp, 0, color=colors[phi])
```
