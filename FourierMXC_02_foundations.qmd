# 2. Foundations of the Fourier transform

```{python}
import numpy as np
import math
import matplotlib.pyplot as plt
import pylab as pl
# from IPython import display
import time as ttime
import random
from mpl_toolkits.mplot3d import Axes3D
```


To understand the Fourier transform from a mathematical and a computational
perspective, you need to understand sine waves, complex numbers and
the dot product. Integrating the first two leads to complex sine waves,
whereas the last two lead to the complex dot product, the two base concepts
to understand the complex Fourier coefficients and the Fourier transform.

# Complex numbers

The real number line is centered at 0, and stretches infinitely, containing all
numbers, both negative (left) and positive (right). On this line, each number
carries two pieces of information: its sign, and its magnitude, indicating
wether if its at the left or the right of 0, and how far it is. This mental
model is good for many cases, but there are problems in mathematics, physics,
engineering, or signal processing that are more tractable working with a number
plane defined with a real, and an imaginary axis ($x$ and $y$, respectively).

The basis of the real axis is the number one, and the basis for the imaginary
axis is the operator $i = \sqrt{-1}$. It is called the imaginary operator
because there is not a quantity that actually exists because no squared number
can be negative. $i$ was created with the intent to solve $x^{2} + 1 = 0$,
where $x = i$. Note the imaginary operator can be written as $i$ or $j$.
Mathematicians tend to prefer the former, whereas engineers use the latter
because $i$ is used for electrical current intensity. 

Also note many mathematicians, scientists and teachers have complained about
using the word 'imaginary'. Even Gauss, who formalized the system of complex
numbers and showed how to use complex numbers for calculus and geometry, hated
the term imaginary and instead suggested that we use the term lateral. But
for better or worse, imaginary is the standard term that everyone uses.

The important thing to keep in mind is the fact Fourier transform uses these
two-component complex numbers. Complex numbers have are referred to using the
real and imaginary axis coordinates, just like how you would refer to $x$
and $y$ coordinates on a normal Cartesian plane.

So at this point, here is 23I, which means two units over positive on the real
xis and three units positive on the imaginary axis.

The reason why complex numbers are so useful is that they pack a lot of
information into a very compact representation. So for just the real number
line, a number has only two pieces of information. Its distance away from the
origin and its sign meaning, whether it's to the left or to the right of zero.

A complex number not only contains the real and imaginary coordinates, also
define a line between this point ant the origin $(0, 0)$, which has an specific
length and an angle relative to the axis... by convention, the positive real
axis.

The Fourier transform returns complex numbers and the distance (magnitude)
and the angle represent the amplitude and the phase at some frequency.

The key to computing the distance from the origin is to think about magnitude
as the hypotenuse of a right triangle where the other two sides are the
projection of the real and imaginary parts into their respective axes.
thus, the squared distance is $|z|^{2}= real(z)^{2} + imag(z)^{2}$. The other
way to calculate the magnitude is to multiply the number by its complex
conjugate, which is the number with the sign of the imaginary part flipped.

$$
zz^{*} = (a + ib)(a - ib) = a^{2} + aib - aib - (bi)^{2} = a^{2} + b^{2}
$$

The other piece of information that we extract from a complex number is the
angle of this line relative to the positive real axis.

From trigonometry we know that the tangent of this angle theta is equal to
the ratio of the imaginary part to the real part. The angle itself can be
computed by calculating the inverse tangent, the arctangent of the fraction.

$$
\tan (\theta) = \frac{imag(z)}{real(z)}
\rightarrow
\theta = \arctan \frac{imag(z)}{real(z)} 
$$

Here, I'm showing that there are several ways to compute a complex number in
Python. One possibility is to add a real and imaginary number and the other
is to use the function `complex`, whose arguments are the real and imaginary
parts, respectively.

```{python}
# writing the complex number as real + imaginary
z = 4 + 1j*3
print(z)

# using the function complex
z = complex(4,3)    # this way
z = complex('4+3j') # or this way
print(z)
```

It is possible to extract the real and imaginary parts of a complex number
using the functions `np.real` and `np.imag`, respectively. Then, it is possible
to plot this number on the complex plane: four units positive on the real axis
and three units positive on the imaginary axis.

```{python}
# plot the complex number on the complex plane

plt.plot(np.real(z),np.imag(z),'ro')

# some plotting touch-ups
plt.axis('square')
plt.axis([-5, 5, -5, 5])
plt.grid(True)
plt.xlabel('Real axis'), plt.ylabel('Imaginary axis')
plt.show()
```

The magnitude of that number (distance away from the origin) can be calculated
using the Pythagorean theorem, or by using the absolute value (`np.abs`), which
is less verbose.

```{python}
# compute the magnitude of the complex number using Pythagorean theorem
mag = np.sqrt( np.real(z)**2 + np.imag(z)**2 )
mag = np.abs(z)

print( 'The magnitude is',mag )
```

If the two sides are three and four, then the hypotenuse must be five.

The angle between the positive real axis and the line connecting the origin
and the complex point can be calculated as the arctangent of the imaginary part
by the real part. It is also possible to use the simpler function `np.angle`

```{python}
phs = math.atan( np.imag(z) / np.real(z) )
phs = np.arctan2(np.imag(z), np.real(z))
phs = np.angle(z)

print( 'The angle is',phs )
```

![XKCD on complex numbers](https://imgs.xkcd.com/comics/complex_numbers.png)

# Euler's formula

Euler's formula is related to complex numbers and Fourier transform: it will
provide a compact notation for representing a lot of detailed spectral
information. It also directly leads to what many people consider to be the most
beautiful equation in all of mathematics.

$$
e^{ik} = \cos(k) + i \sin(k)
$$

$e$ is a famous constant in mathematics that appears in trigonometry, complex
analysis, differential equations or simulations. It is an irrational number
(it keeps going on and on and on forever with no known pattern or limit).
Its approximate value is $e = 2.718...$.

If we plot $e^{x}$ we can see the function always remains positive, starting
from near-zero values when $x$ is negative, and having increasingly larger
values when $x$ is positive.

The derivative of $e^{x}$ is the very same function, which is quite a special
property, although that's not really what we care about here.

Exponentiation of $e$ with a complex number gives $e^{ik}$, where $i$ is the
imaginary operator and $k$ is some number (sometimes written as $\phi$ or
$\theta$).

Euler's formula says that $e^{ik} = \cos(k) + i \sin(k)$. It is a neat formula
because it provides a link between complex numbers and trigonometry.
In particular, if you think about an axis with cosine and sine defining the
two axes, then all values of k, which is the angle of this line here, are
somewhere on this unit circle. You might remember one of the trig identities,
which says that cosine squared plus sine squared equals one, and that means
that for any value K here, this expression corresponds to a unit length vector,
a line that has a length of exactly one placed on the unit circle.

In other words, $e^{ik}$ describes a vector from the origin to some point on
a circle with radius one. Let's have a look in Matlab before moving forwards.

```{python}
# Euler's formula with arbitrary vector magnitude

magnitudes = [1, .5]
phases = [2/np.pi, np.pi/2]

# Make the plots
fig = plt.figure()
cart = plt.subplot(121)
polar = plt.subplot(122, projection='polar')

# Cartesian base
x = np.linspace(-np.pi,np.pi,num=100)
cart.plot(np.cos(x), np.sin(x), 'k', zorder=0)
cart.set_aspect('equal')
cart.grid(True)
cart.set_ylabel('Imaginary axis')
cart.set_xlabel('Real axis')

# Polar base
polar.set_yticks([.5])
polar.set_ylim(top=1)
polar.set_xticks(np.arange(np.pi/4, 2 * np.pi, np.pi/2))

#loop along values
for m, k in zip(magnitudes, phases):

    # The number
    c_number = m * np.exp( 1j * k )

    # Cartesian
    cart.plot([0, m * np.cos(k)], [0, m * np.sin(k)], zorder=1)
    cart.scatter(m * np.cos(k), m * np.sin(k), zorder=2)

    # Polar
    # extract magnitude and angle
    mag = np.abs(c_number)
    phs = np.angle(c_number)
    polar.plot([phs, phs], [0, mag])
    polar.scatter(phs, mag, zorder=2)
```

Here we are plotting a dot on the complex plane. The $x$ the cosine or the
real axis, and $y$ the sine or imaginary axis. Regardless on how arbitrarily 
large or small $k$ is, it still represents a point on this unit circle
on the plane.

So far we have talked about are unit vectors (magnitude of one), which lie on
this unit circle in the complex plane, meaning $k$ is specified on radians.

When $k = \pi$, then $e^{i\pi} = -1 + 0i$, which can be rewritten as
$e^{i\pi} + 1 = 0$. This expression is considered the most beautiful and
elegant mathematical equation ever discovered in human civilization.
It contains four of the most important numbers in mathematics (the rational
numbers $0$ and $1$, and the irrational numbers $e$ and $\pi$), as well as
the the three fundamental arithmetic operations (addition, multiplication
and exponentiation).

To use Euler's formula to describe a vector that is longer or shorter than
the unit circle, it is necessary to multiply this vector by some scalar
(single number, e.g., $m$ for magnitude). This scalar, only changes the
distance away from the origin. So this gives us

$$
m e^{ik} = m ( \cos(k) + i \sin(k) ) = m \cos(k) + m i \sin(k)
$$

$m$ is the magnitude or amplitude, and $k$ is the phase angle $(\theta)$.
This is why Euler's formula is so practical for Fourier analysis: it is
possible to read the critical information right off the number.

First we define a magnitude $m$ and an angle $k$, to generate a complex
number in Euler's notation. Then it is converted into rectangular notation
or Cartesian notation, where you see the projection onto the real axis,
the projection onto the imaginary axis, and we can extract the distance away
from the origin and the angle relative to the positive real axis.

Notice is the dissociation between the length and the angle of the vector.

# Sine waves and complex sine waves

```{python}
# simulation parameters
srate = 500; # sampling rate in Hz
time  = np.arange(0.,2.,1./srate) # time in seconds

# sine wave param.eters
freq = 3;    # frequency in Hz
ampl = 2;    # amplitude in a.u.
phas = np.pi/3; # phase in radians

# generate the sine wave
sinewave = ampl * np.sin( 2*np.pi * freq * time + phas )

plt.plot(time,sinewave,'k')
plt.xlabel('Time (sec.)')
plt.ylabel('Amplitude (a.u.)')
plt.show()
```

```{python}
# sine and cosine are the same but for a phase shift

# generate the sine wave
sinewave = ampl * np.sin( 2*np.pi * freq * time + phas )
coswave  = ampl * np.cos( 2*np.pi * freq * time + phas )

plt.plot(time,sinewave,'k',label='sine')
plt.plot(time,coswave,'r',label='cosine')
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude')
plt.title('A sine and cosine with the same parameters.')
plt.show()
```


```{python}
# complex sine waves

# general simulation parameters
srate = 500; # sampling rate in Hz
time  = np.arange(0.,2.,1./srate) # time in seconds

# sine wave parameters
freq = 5;    # frequency in Hz
ampl = 2;    # amplitude in a.u.
phas = np.pi/3; # phase in radians

# generate the sine wave
csw = ampl * np.exp( 1j* (2*np.pi * freq * time + phas) );

# plot the results
plt.plot(time,np.real(csw),label='real')
plt.plot(time,np.imag(csw),label='imag')
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude')
plt.title('Complex sine wave projections')
plt.legend()
plt.show()

```


```{python}
# now show in 3D
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
ax.plot(time,np.real(csw),np.imag(csw))
ax.set_xlabel('Time (s)'), ax.set_ylabel('Real part'), ax.set_zlabel('Imag part')
ax.set_title('Complex sine wave in all its 3D glory')
plt.show()
```


---
# VIDEO: The dot product
---



```{python}
# two vectors
v1 = [ 1, 2, 3 ];
v2 = [ 3, 2, 1 ];

# compute the dot product
dp = sum( np.multiply(v1,v2) )

print('The dot product is',dp)
```


```{python}
# dot products of sine waves

# general simulation parameters
srate = 500; # sampling rate in Hz
time  = np.arange(0.,2.,1./srate) # time in seconds

# sine wave parameters
freq1 = 5;    # frequency in Hz
freq2 = 5;    # frequency in Hz

ampl1 = 2;    # amplitude in a.u.
ampl2 = 2;    # amplitude in a.u.

phas1 = np.pi/2; # phase in radians
phas2 = np.pi/2; # phase in radians

# generate the sine wave
sinewave1 = ampl1 * np.sin( 2*np.pi * freq1 * time + phas1 );
sinewave2 = ampl2 * np.sin( 2*np.pi * freq2 * time + phas2 );

# compute dot product
dp = np.dot(sinewave1,sinewave2);

# print result
print('dp =',dp)
```


```{python}
# with a signal

# phase of signal
theta = 0*np.pi/4;


# simulation parameters
srate = 1000;
time  = np.arange(-1.,1.,1./srate)

# signal
sinew  = np.sin(2*np.pi*5*time + theta)
gauss  = np.exp( (-time**2) / .1);
signal = np.multiply(sinew,gauss)

# sine wave frequencies
sinefrex = np.arange(2.,10.,.5);

# plot signal
plt.plot(time,signal)
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude (a.u.)')
plt.title('Signal')
plt.show()



# initialize dot products vector
dps = np.zeros(len(sinefrex));

# loop over sine waves
for fi in range(len(dps)):

    # create sine wave
    sinew = np.sin( 2*np.pi*sinefrex[fi]*time)

    # compute dot product
    dps[fi] = np.dot( sinew,signal ) / len(time)


# and plot
plt.stem(sinefrex,dps)
plt.xlabel('Sine wave frequency (Hz)'), plt.ylabel('Dot product')
plt.title('Dot products with sine waves')
plt.show()
```


---
# VIDEO: The complex dot product
---



```{python}
# phase of signal
theta = 0*np.pi/4;


# simulation parameters
srate = 1000;
time  = np.arange(-1.,1.,1./srate)

# signal
sinew  = np.sin(2*np.pi*5*time + theta)
gauss  = np.exp( (-time**2) / .1);
signal = np.multiply(sinew,gauss)


# sine wave frequencies
sinefrex = np.arange(2.,10.,.5);

# plot signal
plt.plot(time,signal)
plt.xlabel('Time (sec.)'), plt.ylabel('Amplitude (a.u.)')
plt.title('Signal')
plt.show()



# initialize dot products vector
dps = np.zeros(len(sinefrex),dtype=complex)

# loop over sine waves
for fi in range(len(dps)):

    # create sine wave
    sinew = np.exp( 1j*2*np.pi*sinefrex[fi]*time )

    # compute dot product
    dps[fi] = np.abs( np.vdot( sinew,signal ) / len(time) )


# and plot
plt.stem(sinefrex,dps)
plt.xlabel('Sine wave frequency (Hz)'), plt.ylabel('Dot product')
plt.title('Dot products with sine waves')
plt.show()
```


```{python}
# in more detail...

# phase of signal
theta = 1*np.pi/4;

# signal
sinew  = np.sin(2*np.pi*5*time + theta)
gauss  = np.exp( (-time**2) / .1)
signal = np.multiply(sinew,gauss)

# create sine and cosine waves
sinew = np.sin( 2*np.pi*5*time )
cosnw = np.cos( 2*np.pi*5*time )

# compute dot products
dps = np.dot( sinew,signal ) / len(time)
dpc = np.dot( cosnw,signal ) / len(time)

# combine sine and cosine into complex dot product
dp_complex = complex(dpc,dps) # cos/sin were swapped in the video
mag = np.abs(dp_complex)
phs = np.angle(dp_complex)

# and plot
plt.plot( dpc , dps ,'ro')
plt.xlabel('Cosine axis')
plt.ylabel('Sine axis')
plt.axis('square')
plt.grid(True)
plt.axis([-.2,.2,-.2,.2])
plt.show()

# draw a line using polar notation
plt.polar([phs,phs],[0,mag])
plt.show()
```


```{python}

# create complex sine wave
csw = np.exp( 1j*2*np.pi*5*time )
rsw = np.sin(    2*np.pi*5*time )

# specify range of phase offsets for signal
phases = np.arange(0, 2 * np.pi, np.pi/4) # np.linspace(0, 7 * np.pi/2, num=8)

# Prepare the colors
cmap = plt.get_cmap('hsv')
colors = cmap(np.linspace(0, 1, len(phases) + 1))

# create a figure as a subplot mosaic
fig = plt.figure(figsize=(5, 5), layout='constrained')
axes = fig.subplot_mosaic([['time', 'time'], ['complex', 'normal']])
axes['time'].set_title('Signal and sine wave over time')

# Plot rsw a single time
axes['time'].plot(time, rsw, color='k', lw=2.5, zorder=0)
axes['time'].set_xlim(-.75, .75)

for plot_id in ('complex', 'normal'):
    axes[plot_id].set_title(f"{plot_id.capitalize()} dot product")
    axes[plot_id].set_aspect('equal')
    axes[plot_id].set_ylim(-.175, .175)
    axes[plot_id].set_ylabel('Imaginary')
    axes[plot_id].set_xlim(-.175, .175)
    axes[plot_id].set_xlabel('Real')
    axes[plot_id].axhline(0, color='k', zorder=0)
    axes[plot_id].axvline(0, color='k', zorder=0)

for phi in range(0,len(phases)):

    # create signal
    sinew  = np.sin(2*np.pi*5*time + phases[phi])
    gauss  = np.exp( (-time**2) / .1)
    signal = np.multiply(sinew, gauss)

    # compute complex dot product
    cdp = np.sum( np.multiply(signal,csw) ) / len(time)

    # compute real-valued dot product
    rdp = sum( np.multiply(signal,rsw) ) / len(time)

    # plot signal and real part of sine wave
    axes['time'].plot(time, signal, color=colors[phi])

    # plot complex dot product
    axes['complex'].scatter(np.real(cdp), np.imag(cdp), color=colors[phi])
    axes['complex'].plot([0, np.real(cdp)], [0, np.imag(cdp)], color=colors[phi])

    # plot normal dot producr
    axes['normal'].scatter(rdp, 0, color=colors[phi])
```
